#include "engine.h"

#define CGLTF_IMPLEMENTATION
#include <cgltf.h>

#include <stb_image.h>

#include <chrono>
#include <vector>
#include <iostream>
#include <algorithm> // Necessary for std::clamp
#include <array>
#include <threads.h>

#include "inireader.h"

#include "engineUtils.h"
#include "BackendUtils.h"
#include "VulkanBackend.h"

// using lua_pcall will warn you about errors, but can slow things down, so it's togglable
//#define LUA_PROTECTCALL

static void* LuaAllocator(void* ud, void* ptr, size_t osize, size_t nsize)
{
	if (!nsize)
	{
		free(ptr);
		return NULL;
	}

	return realloc(ptr, nsize);
}

bool showConsole = false;

// Default Window Size
uint32_t Width = 1280;
uint32_t Height = 720;

struct ObjectMoveStruct
{
	MeshObject* target;
	float3 moveTo;
	float moveSpeed;
	const char* callback;
};

uint32_t numMovingObjects;
ObjectMoveStruct movingObjects[50];

#include "luaGLMlib.h"
#include "luaGLFWlib.h"

char printbuffer[256];
float timer = 0.0f;


// Objects that have lua code associated with them
std::vector<MeshObject*> allThinkers;


#define ReadSnippet_CheckBoundary(ptr, end) if (ptr >= end) { std::cout << "ReadSnippet() went past buffer!"; return (char*)""; }

static char* ReadSnippet(char* ptr, char* end, char* buffer)
{
	ReadSnippet_CheckBoundary(ptr, end);

	while (isspace(*ptr)) ptr++;

	ReadSnippet_CheckBoundary(ptr, end);

	while (*ptr == '#')
	{
		while (*ptr != '\n') ptr++;

		ReadSnippet_CheckBoundary(ptr, end);

		while (isspace(*ptr)) ptr++;

		ReadSnippet_CheckBoundary(ptr, end);
	}

	ReadSnippet_CheckBoundary(ptr, end);

	while (!isspace(*ptr))
		*buffer++ = *ptr++;

	return ++ptr;
}


static float WithinBounds(float point, float min, float max)
{
	return point < max && point > min;
}

static bool InsideBoundingBox(float3 point, float3 min, float3 max)
{
	return WithinBounds(point.x, min.x, max.x) && WithinBounds(point.y, min.y, max.y) && WithinBounds(point.z, min.z, max.z);
}


static bool RayBox(float3 rayOrigin, float3 rayDir, float3 boxOrigin, float3 boxSize, float3& outCoords)
{
	float3 min = boxOrigin - boxSize;
	float3 max = boxOrigin + boxSize;
	return HitBoundingBox(min, max, rayOrigin, rayDir, outCoords);
}

static auto startTime = std::chrono::high_resolution_clock::now();

// The returned string will need to be free'd at some point
char* ReplaceFilenameExtension(const char* filename, const char* extension, size_t extension_length)
{
	char* newStr = (char*)malloc(256);
	char i = 0;

	if (newStr)
	{
		ZEROMEM(newStr, 256);

		while (*filename != '.')
		{
			newStr[i++] = *filename;
			filename++;
		}

		StringCopy(&newStr[i], (char*)extension, extension_length);

		void* newptr = realloc(newStr, i + extension_length);
		if (newptr)
			newStr = (char*)newptr;
	}
	return newStr;
}

VulkanEngine* g_App;

#define AddLuaFunc(state, func, name) lua_pushcclosure(state, func, 0); \
														  lua_setglobal(state, name)
#include "luafunctions.h"

struct LevelData_Shader
{
	const char* vertexShaderFilename;
	const char* pixelShaderFilename;
	int shaderType;
	VkCullModeFlags cullMode;
	VkPolygonMode polygonMode;
	BlendMode alphaBlending;
	uint32_t stencilWriteValue;
	bool depthTest;
	bool depthWrite;
	bool masked;
	const char* zlslFilename;
};

const std::vector<LevelData_Shader> shaders = {
	{ "shaders/staticVert_vert.spv", "shaders/diffuse_pixl.spv",			   SF_DEFAULT, VK_CULL_MODE_BACK_BIT, VK_POLYGON_MODE_FILL, BM_OPAQUE,		  0, true, false, false, "shaders/diffuse.zlsl"              }, // Opaque Non-Metal
	{ "shaders/staticVert_vert.spv", "shaders/metal_pixl.spv",				   SF_DEFAULT, VK_CULL_MODE_BACK_BIT, VK_POLYGON_MODE_FILL, BM_OPAQUE,		  0, true, false, false, "shaders/metal.zlsl"                }, // Opaque Metal
	{ "shaders/staticVert_vert.spv", "shaders/glass_pixl.spv",				   SF_ALPHA,	   VK_CULL_MODE_BACK_BIT, VK_POLYGON_MODE_FILL, BM_TRANSPARENT, 0, true, false, false, "shaders/glass.zlsl"                }, // Glass
	{ "shaders/skybox_vert.spv", "shaders/skybox_pixl.spv",			   SF_SKYBOX,  VK_CULL_MODE_BACK_BIT, VK_POLYGON_MODE_FILL, BM_OPAQUE,		  2, true, false, false, "shaders/skybox.zlsl"             }, // Skybox
	{ "shaders/staticVert_vert.spv", "shaders/diffuse-masked_pixl.spv", SF_DEFAULT, VK_CULL_MODE_BACK_BIT, VK_POLYGON_MODE_FILL, BM_OPAQUE,		  0, true, true, true,   "shaders/diffuse-masked.zlsl" }, // Alpha Non-Metal
	{ "shaders/staticVert_vert.spv", "shaders/metal-masked_pixl.spv",  SF_DEFAULT, VK_CULL_MODE_BACK_BIT, VK_POLYGON_MODE_FILL, BM_OPAQUE,			  0, true, true, true,   "shaders/metal-masked.zlsl"  }, // Alpha Metal
};

void OnGUIError(VkResult err)
{

}

bool locked = true;

void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
	if (action == GLFW_PRESS)
	{
		if (key == GLFW_KEY_GRAVE_ACCENT)
			showConsole = !showConsole;

		if (key == GLFW_KEY_TAB)
		{
			locked = !locked;
			glfwSetInputMode(window, GLFW_CURSOR, locked ? GLFW_CURSOR_DISABLED : GLFW_CURSOR_NORMAL);
			glfwSetInputMode(window, GLFW_RAW_MOUSE_MOTION, locked ? GLFW_TRUE : GLFW_FALSE);
		}

	}

	lua_getglobal(g_App->L, "KeyCallback");
	lua_pushinteger(g_App->L, key);
	lua_pushinteger(g_App->L, scancode);
	lua_pushinteger(g_App->L, action);
	lua_pushinteger(g_App->L, mods);
	lua_call(g_App->L, 4, 0);
}

const float pi = 3.14159f;
const float halfpi = 1.57079f;

float moveSensitivity = 0.05f;

volatile bool threadAwaitingSync;
volatile bool threadSynced;
bool RecompileShaderThreadProc(void* glWindow);

size_t minFrametime = 8000;
int maxFPS = 165;

#define NUMCONSOLEVARS 6

ConsoleCommandVar consoleVars[NUMCONSOLEVARS] = {
	{ "LookSensitivity", (void*)&LOOK_SENSITIVITY, CCVT_FLOAT },
	{ "minFrametime", (void*)&minFrametime, CCVT_ULONG },
	{ "moveSensitivity", (void*)&moveSensitivity, CCVT_FLOAT },
	{ "pi", (void*)&pi, CCVT_FLOAT },
	{ "halfpi", (void*)&halfpi, CCVT_FLOAT }
};


void VulkanEngine::CompileShaderFromFilename(const char* from, const char* to)
{
	ZEROMEM(printbuffer, 256);
	sprintf(printbuffer, "D:\\VulkanSDK\\Bin\\glslc.exe %s -o %s", from, to);
	system(printbuffer);
}

void VulkanEngine::StringReplace(char* string, char subject, char replacement)
{
	while (*string)
	{
		if (*string == subject)
			*string = replacement;

		string++;
	}
}

void VulkanEngine::TurnSPVIntoFilename(const char* spv, bool bVertex, char* outString)
{
	size_t length;

	const char* index = strchr(spv, '_');
	if (index)
	{
		length = (size_t)(index - spv);
		StrnCopySafe(outString, 256, spv, length);
		StrnConcatSafe(outString, 256, bVertex ? ".vert" : ".frag", 5);
	}
}

void VulkanEngine::RecompileComputeShader(ComputeShader* shader)
{
	CompileShaderFromFilename(shader->filename, shader->spvFilename);
}

void VulkanEngine::RecompileShader(Shader* pipeline)
{
	// First is the source-to-source compiler, to make writing the shaders easier
	system("C:\\Users\\zackw\\AppData\\Local\\Programs\\Python\\Python312\\python.exe C:\\Users\\zackw\\Desktop\\py\\glsltool.py");

	TurnSPVIntoFilename(pipeline->vertexShader, true, filename1);
	TurnSPVIntoFilename(pipeline->pixelShader, false, filename2);

	CompileShaderFromFilename(filename1, "on_fly_vert.spv");
	CompileShaderFromFilename(filename2, "on_fly_pixl.spv");

	vkDeviceWaitIdle(this->backend->logicalDevice);
	vkDestroyPipeline(this->backend->logicalDevice, pipeline->pipeline, nullptr);
	vkDestroyPipelineLayout(this->backend->logicalDevice, pipeline->pipelineLayout, nullptr);

	this->backend->createGraphicsPipeline("on_fly_vert.spv", "on_fly_pixl.spv", (pipeline->shaderType != SF_POSTPROCESS && pipeline->shaderType < SF_SHADOW) ? backend->mainRenderPass : pipeline->renderPass, pipeline->setLayouts.data(), pipeline->setLayouts.size(), pipeline->shaderType, this->backend->swapChainExtent, pipeline->cullMode, pipeline->polygonMode, pipeline->sampleCount, pipeline->alphaBlend, pipeline->depthTest, pipeline->depthWrite, &pipeline->pushConstantRange, (bool)pipeline->pushConstantRange.stageFlags, pipeline->numAttachments, pipeline->stencilWriteMask, pipeline->stencilCompareOp, pipeline->stencilTestValue, pipeline->depthBias, &pipeline->pipelineLayout, &pipeline->pipeline);
}

void VulkanEngine::CheckIfShaderNeedsRecompilation(Shader* pipeline, bool reRecord)
{
	auto mod_time = FileDate(pipeline->zlslFile);
	if (mod_time != pipeline->mtime)
	{
		printf("'%s' has changed\n", pipeline->zlslFile);
		pipeline->mtime = mod_time;
		RecompileShader(pipeline);
		if (reRecord)
			backend->RecordPostProcessCommandBuffers();
	}
}

VkDescriptorSetLayout* VulkanEngine::GetDescriptorSetLayoutFromZLSL(const char* zlsl)
{
	size_t numVBuffers, numPBuffers, numSamplers, numVPushBuffers, numPPushBuffers, numAttachments;
	GetInfoFromZLSL(zlsl, &numSamplers, &numVBuffers, &numPBuffers, &numVPushBuffers, &numPPushBuffers, &numAttachments, NULL);
	return backend->GetDescriptorSetLayout(numVBuffers, numPBuffers, numSamplers);
}

void VulkanEngine::InitLua()
{

	L = lua_newstate(LuaAllocator, this);
	luaL_openlibs(L);

	AddLuaFunc(L, LuaFN_CreateRenderPass, "CreateRenderPass");
	AddLuaFunc(L, LuaFN_CreateImage, "CreateImage");
	AddLuaFunc(L, LuaFN_CreateFrameBuffer, "CreateFrameBuffer");
	AddLuaFunc(L, LuaFN_OneTimeBlit, "OneTimeBlit");
	AddLuaFunc(L, LuaFN_LoadImage, "LoadImage");

	AddLuaGlobalInt(VK_SUBPASS_EXTERNAL, "VK_SUBPASS_EXTERNAL");

	// I made a python script to auto generate all of these, otherwise this would have taken forever
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_UNDEFINED, "VK_IMAGE_LAYOUT_UNDEFINED");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_GENERAL, "VK_IMAGE_LAYOUT_GENERAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_PREINITIALIZED, "VK_IMAGE_LAYOUT_PREINITIALIZED");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL, "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL, "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR, "VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR, "VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR, "VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT, "VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR, "VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR, "VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR, "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR, "VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR, "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT, "VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR, "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR, "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV, "VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR, "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR, "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR, "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR, "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR, "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR");
	AddLuaGlobalInt(VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR, "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR");

	AddLuaGlobalInt(VK_FORMAT_UNDEFINED, "VK_FORMAT_UNDEFINED");
	AddLuaGlobalInt(VK_FORMAT_R4G4_UNORM_PACK8, "VK_FORMAT_R4G4_UNORM_PACK8");
	AddLuaGlobalInt(VK_FORMAT_R4G4B4A4_UNORM_PACK16, "VK_FORMAT_R4G4B4A4_UNORM_PACK16");
	AddLuaGlobalInt(VK_FORMAT_B4G4R4A4_UNORM_PACK16, "VK_FORMAT_B4G4R4A4_UNORM_PACK16");
	AddLuaGlobalInt(VK_FORMAT_R5G6B5_UNORM_PACK16, "VK_FORMAT_R5G6B5_UNORM_PACK16");
	AddLuaGlobalInt(VK_FORMAT_B5G6R5_UNORM_PACK16, "VK_FORMAT_B5G6R5_UNORM_PACK16");
	AddLuaGlobalInt(VK_FORMAT_R5G5B5A1_UNORM_PACK16, "VK_FORMAT_R5G5B5A1_UNORM_PACK16");
	AddLuaGlobalInt(VK_FORMAT_B5G5R5A1_UNORM_PACK16, "VK_FORMAT_B5G5R5A1_UNORM_PACK16");
	AddLuaGlobalInt(VK_FORMAT_A1R5G5B5_UNORM_PACK16, "VK_FORMAT_A1R5G5B5_UNORM_PACK16");
	AddLuaGlobalInt(VK_FORMAT_R8_UNORM, "VK_FORMAT_R8_UNORM");
	AddLuaGlobalInt(VK_FORMAT_R8_SNORM, "VK_FORMAT_R8_SNORM");
	AddLuaGlobalInt(VK_FORMAT_R8_USCALED, "VK_FORMAT_R8_USCALED");
	AddLuaGlobalInt(VK_FORMAT_R8_SSCALED, "VK_FORMAT_R8_SSCALED");
	AddLuaGlobalInt(VK_FORMAT_R8_UINT, "VK_FORMAT_R8_UINT");
	AddLuaGlobalInt(VK_FORMAT_R8_SINT, "VK_FORMAT_R8_SINT");
	AddLuaGlobalInt(VK_FORMAT_R8_SRGB, "VK_FORMAT_R8_SRGB");
	AddLuaGlobalInt(VK_FORMAT_R8G8_UNORM, "VK_FORMAT_R8G8_UNORM");
	AddLuaGlobalInt(VK_FORMAT_R8G8_SNORM, "VK_FORMAT_R8G8_SNORM");
	AddLuaGlobalInt(VK_FORMAT_R8G8_USCALED, "VK_FORMAT_R8G8_USCALED");
	AddLuaGlobalInt(VK_FORMAT_R8G8_SSCALED, "VK_FORMAT_R8G8_SSCALED");
	AddLuaGlobalInt(VK_FORMAT_R8G8_UINT, "VK_FORMAT_R8G8_UINT");
	AddLuaGlobalInt(VK_FORMAT_R8G8_SINT, "VK_FORMAT_R8G8_SINT");
	AddLuaGlobalInt(VK_FORMAT_R8G8_SRGB, "VK_FORMAT_R8G8_SRGB");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8_UNORM, "VK_FORMAT_R8G8B8_UNORM");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8_SNORM, "VK_FORMAT_R8G8B8_SNORM");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8_USCALED, "VK_FORMAT_R8G8B8_USCALED");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8_SSCALED, "VK_FORMAT_R8G8B8_SSCALED");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8_UINT, "VK_FORMAT_R8G8B8_UINT");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8_SINT, "VK_FORMAT_R8G8B8_SINT");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8_SRGB, "VK_FORMAT_R8G8B8_SRGB");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8_UNORM, "VK_FORMAT_B8G8R8_UNORM");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8_SNORM, "VK_FORMAT_B8G8R8_SNORM");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8_USCALED, "VK_FORMAT_B8G8R8_USCALED");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8_SSCALED, "VK_FORMAT_B8G8R8_SSCALED");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8_UINT, "VK_FORMAT_B8G8R8_UINT");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8_SINT, "VK_FORMAT_B8G8R8_SINT");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8_SRGB, "VK_FORMAT_B8G8R8_SRGB");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8A8_UNORM, "VK_FORMAT_R8G8B8A8_UNORM");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8A8_SNORM, "VK_FORMAT_R8G8B8A8_SNORM");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8A8_USCALED, "VK_FORMAT_R8G8B8A8_USCALED");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8A8_SSCALED, "VK_FORMAT_R8G8B8A8_SSCALED");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8A8_UINT, "VK_FORMAT_R8G8B8A8_UINT");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8A8_SINT, "VK_FORMAT_R8G8B8A8_SINT");
	AddLuaGlobalInt(VK_FORMAT_R8G8B8A8_SRGB, "VK_FORMAT_R8G8B8A8_SRGB");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8A8_UNORM, "VK_FORMAT_B8G8R8A8_UNORM");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8A8_SNORM, "VK_FORMAT_B8G8R8A8_SNORM");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8A8_USCALED, "VK_FORMAT_B8G8R8A8_USCALED");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8A8_SSCALED, "VK_FORMAT_B8G8R8A8_SSCALED");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8A8_UINT, "VK_FORMAT_B8G8R8A8_UINT");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8A8_SINT, "VK_FORMAT_B8G8R8A8_SINT");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8A8_SRGB, "VK_FORMAT_B8G8R8A8_SRGB");
	AddLuaGlobalInt(VK_FORMAT_A8B8G8R8_UNORM_PACK32, "VK_FORMAT_A8B8G8R8_UNORM_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A8B8G8R8_SNORM_PACK32, "VK_FORMAT_A8B8G8R8_SNORM_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A8B8G8R8_USCALED_PACK32, "VK_FORMAT_A8B8G8R8_USCALED_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A8B8G8R8_SSCALED_PACK32, "VK_FORMAT_A8B8G8R8_SSCALED_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A8B8G8R8_UINT_PACK32, "VK_FORMAT_A8B8G8R8_UINT_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A8B8G8R8_SINT_PACK32, "VK_FORMAT_A8B8G8R8_SINT_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A8B8G8R8_SRGB_PACK32, "VK_FORMAT_A8B8G8R8_SRGB_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2R10G10B10_UNORM_PACK32, "VK_FORMAT_A2R10G10B10_UNORM_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2R10G10B10_SNORM_PACK32, "VK_FORMAT_A2R10G10B10_SNORM_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2R10G10B10_USCALED_PACK32, "VK_FORMAT_A2R10G10B10_USCALED_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2R10G10B10_SSCALED_PACK32, "VK_FORMAT_A2R10G10B10_SSCALED_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2R10G10B10_UINT_PACK32, "VK_FORMAT_A2R10G10B10_UINT_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2R10G10B10_SINT_PACK32, "VK_FORMAT_A2R10G10B10_SINT_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2B10G10R10_UNORM_PACK32, "VK_FORMAT_A2B10G10R10_UNORM_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2B10G10R10_SNORM_PACK32, "VK_FORMAT_A2B10G10R10_SNORM_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2B10G10R10_USCALED_PACK32, "VK_FORMAT_A2B10G10R10_USCALED_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2B10G10R10_SSCALED_PACK32, "VK_FORMAT_A2B10G10R10_SSCALED_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2B10G10R10_UINT_PACK32, "VK_FORMAT_A2B10G10R10_UINT_PACK32");
	AddLuaGlobalInt(VK_FORMAT_A2B10G10R10_SINT_PACK32, "VK_FORMAT_A2B10G10R10_SINT_PACK32");
	AddLuaGlobalInt(VK_FORMAT_R16_UNORM, "VK_FORMAT_R16_UNORM");
	AddLuaGlobalInt(VK_FORMAT_R16_SNORM, "VK_FORMAT_R16_SNORM");
	AddLuaGlobalInt(VK_FORMAT_R16_USCALED, "VK_FORMAT_R16_USCALED");
	AddLuaGlobalInt(VK_FORMAT_R16_SSCALED, "VK_FORMAT_R16_SSCALED");
	AddLuaGlobalInt(VK_FORMAT_R16_UINT, "VK_FORMAT_R16_UINT");
	AddLuaGlobalInt(VK_FORMAT_R16_SINT, "VK_FORMAT_R16_SINT");
	AddLuaGlobalInt(VK_FORMAT_R16_SFLOAT, "VK_FORMAT_R16_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_R16G16_UNORM, "VK_FORMAT_R16G16_UNORM");
	AddLuaGlobalInt(VK_FORMAT_R16G16_SNORM, "VK_FORMAT_R16G16_SNORM");
	AddLuaGlobalInt(VK_FORMAT_R16G16_USCALED, "VK_FORMAT_R16G16_USCALED");
	AddLuaGlobalInt(VK_FORMAT_R16G16_SSCALED, "VK_FORMAT_R16G16_SSCALED");
	AddLuaGlobalInt(VK_FORMAT_R16G16_UINT, "VK_FORMAT_R16G16_UINT");
	AddLuaGlobalInt(VK_FORMAT_R16G16_SINT, "VK_FORMAT_R16G16_SINT");
	AddLuaGlobalInt(VK_FORMAT_R16G16_SFLOAT, "VK_FORMAT_R16G16_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16_UNORM, "VK_FORMAT_R16G16B16_UNORM");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16_SNORM, "VK_FORMAT_R16G16B16_SNORM");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16_USCALED, "VK_FORMAT_R16G16B16_USCALED");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16_SSCALED, "VK_FORMAT_R16G16B16_SSCALED");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16_UINT, "VK_FORMAT_R16G16B16_UINT");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16_SINT, "VK_FORMAT_R16G16B16_SINT");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16_SFLOAT, "VK_FORMAT_R16G16B16_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16A16_UNORM, "VK_FORMAT_R16G16B16A16_UNORM");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16A16_SNORM, "VK_FORMAT_R16G16B16A16_SNORM");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16A16_USCALED, "VK_FORMAT_R16G16B16A16_USCALED");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16A16_SSCALED, "VK_FORMAT_R16G16B16A16_SSCALED");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16A16_UINT, "VK_FORMAT_R16G16B16A16_UINT");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16A16_SINT, "VK_FORMAT_R16G16B16A16_SINT");
	AddLuaGlobalInt(VK_FORMAT_R16G16B16A16_SFLOAT, "VK_FORMAT_R16G16B16A16_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_R32_UINT, "VK_FORMAT_R32_UINT");
	AddLuaGlobalInt(VK_FORMAT_R32_SINT, "VK_FORMAT_R32_SINT");
	AddLuaGlobalInt(VK_FORMAT_R32_SFLOAT, "VK_FORMAT_R32_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_R32G32_UINT, "VK_FORMAT_R32G32_UINT");
	AddLuaGlobalInt(VK_FORMAT_R32G32_SINT, "VK_FORMAT_R32G32_SINT");
	AddLuaGlobalInt(VK_FORMAT_R32G32_SFLOAT, "VK_FORMAT_R32G32_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_R32G32B32_UINT, "VK_FORMAT_R32G32B32_UINT");
	AddLuaGlobalInt(VK_FORMAT_R32G32B32_SINT, "VK_FORMAT_R32G32B32_SINT");
	AddLuaGlobalInt(VK_FORMAT_R32G32B32_SFLOAT, "VK_FORMAT_R32G32B32_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_R32G32B32A32_UINT, "VK_FORMAT_R32G32B32A32_UINT");
	AddLuaGlobalInt(VK_FORMAT_R32G32B32A32_SINT, "VK_FORMAT_R32G32B32A32_SINT");
	AddLuaGlobalInt(VK_FORMAT_R32G32B32A32_SFLOAT, "VK_FORMAT_R32G32B32A32_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_R64_UINT, "VK_FORMAT_R64_UINT");
	AddLuaGlobalInt(VK_FORMAT_R64_SINT, "VK_FORMAT_R64_SINT");
	AddLuaGlobalInt(VK_FORMAT_R64_SFLOAT, "VK_FORMAT_R64_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_R64G64_UINT, "VK_FORMAT_R64G64_UINT");
	AddLuaGlobalInt(VK_FORMAT_R64G64_SINT, "VK_FORMAT_R64G64_SINT");
	AddLuaGlobalInt(VK_FORMAT_R64G64_SFLOAT, "VK_FORMAT_R64G64_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_R64G64B64_UINT, "VK_FORMAT_R64G64B64_UINT");
	AddLuaGlobalInt(VK_FORMAT_R64G64B64_SINT, "VK_FORMAT_R64G64B64_SINT");
	AddLuaGlobalInt(VK_FORMAT_R64G64B64_SFLOAT, "VK_FORMAT_R64G64B64_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_R64G64B64A64_UINT, "VK_FORMAT_R64G64B64A64_UINT");
	AddLuaGlobalInt(VK_FORMAT_R64G64B64A64_SINT, "VK_FORMAT_R64G64B64A64_SINT");
	AddLuaGlobalInt(VK_FORMAT_R64G64B64A64_SFLOAT, "VK_FORMAT_R64G64B64A64_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_B10G11R11_UFLOAT_PACK32, "VK_FORMAT_B10G11R11_UFLOAT_PACK32");
	AddLuaGlobalInt(VK_FORMAT_E5B9G9R9_UFLOAT_PACK32, "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32");
	AddLuaGlobalInt(VK_FORMAT_D16_UNORM, "VK_FORMAT_D16_UNORM");
	AddLuaGlobalInt(VK_FORMAT_X8_D24_UNORM_PACK32, "VK_FORMAT_X8_D24_UNORM_PACK32");
	AddLuaGlobalInt(VK_FORMAT_D32_SFLOAT, "VK_FORMAT_D32_SFLOAT");
	AddLuaGlobalInt(VK_FORMAT_S8_UINT, "VK_FORMAT_S8_UINT");
	AddLuaGlobalInt(VK_FORMAT_D16_UNORM_S8_UINT, "VK_FORMAT_D16_UNORM_S8_UINT");
	AddLuaGlobalInt(VK_FORMAT_D24_UNORM_S8_UINT, "VK_FORMAT_D24_UNORM_S8_UINT");
	AddLuaGlobalInt(VK_FORMAT_D32_SFLOAT_S8_UINT, "VK_FORMAT_D32_SFLOAT_S8_UINT");
	AddLuaGlobalInt(VK_FORMAT_BC1_RGB_UNORM_BLOCK, "VK_FORMAT_BC1_RGB_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC1_RGB_SRGB_BLOCK, "VK_FORMAT_BC1_RGB_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC1_RGBA_UNORM_BLOCK, "VK_FORMAT_BC1_RGBA_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC1_RGBA_SRGB_BLOCK, "VK_FORMAT_BC1_RGBA_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC2_UNORM_BLOCK, "VK_FORMAT_BC2_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC2_SRGB_BLOCK, "VK_FORMAT_BC2_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC3_UNORM_BLOCK, "VK_FORMAT_BC3_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC3_SRGB_BLOCK, "VK_FORMAT_BC3_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC4_UNORM_BLOCK, "VK_FORMAT_BC4_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC4_SNORM_BLOCK, "VK_FORMAT_BC4_SNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC5_UNORM_BLOCK, "VK_FORMAT_BC5_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC5_SNORM_BLOCK, "VK_FORMAT_BC5_SNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC6H_UFLOAT_BLOCK, "VK_FORMAT_BC6H_UFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC6H_SFLOAT_BLOCK, "VK_FORMAT_BC6H_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC7_UNORM_BLOCK, "VK_FORMAT_BC7_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_BC7_SRGB_BLOCK, "VK_FORMAT_BC7_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK, "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK, "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK, "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_EAC_R11_UNORM_BLOCK, "VK_FORMAT_EAC_R11_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_EAC_R11_SNORM_BLOCK, "VK_FORMAT_EAC_R11_SNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_EAC_R11G11_UNORM_BLOCK, "VK_FORMAT_EAC_R11G11_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_EAC_R11G11_SNORM_BLOCK, "VK_FORMAT_EAC_R11G11_SNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_4x4_UNORM_BLOCK, "VK_FORMAT_ASTC_4x4_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_4x4_SRGB_BLOCK, "VK_FORMAT_ASTC_4x4_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_5x4_UNORM_BLOCK, "VK_FORMAT_ASTC_5x4_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_5x4_SRGB_BLOCK, "VK_FORMAT_ASTC_5x4_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_5x5_UNORM_BLOCK, "VK_FORMAT_ASTC_5x5_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_5x5_SRGB_BLOCK, "VK_FORMAT_ASTC_5x5_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_6x5_UNORM_BLOCK, "VK_FORMAT_ASTC_6x5_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_6x5_SRGB_BLOCK, "VK_FORMAT_ASTC_6x5_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_6x6_UNORM_BLOCK, "VK_FORMAT_ASTC_6x6_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_6x6_SRGB_BLOCK, "VK_FORMAT_ASTC_6x6_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x5_UNORM_BLOCK, "VK_FORMAT_ASTC_8x5_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x5_SRGB_BLOCK, "VK_FORMAT_ASTC_8x5_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x6_UNORM_BLOCK, "VK_FORMAT_ASTC_8x6_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x6_SRGB_BLOCK, "VK_FORMAT_ASTC_8x6_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x8_UNORM_BLOCK, "VK_FORMAT_ASTC_8x8_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x8_SRGB_BLOCK, "VK_FORMAT_ASTC_8x8_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x5_UNORM_BLOCK, "VK_FORMAT_ASTC_10x5_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x5_SRGB_BLOCK, "VK_FORMAT_ASTC_10x5_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x6_UNORM_BLOCK, "VK_FORMAT_ASTC_10x6_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x6_SRGB_BLOCK, "VK_FORMAT_ASTC_10x6_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x8_UNORM_BLOCK, "VK_FORMAT_ASTC_10x8_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x8_SRGB_BLOCK, "VK_FORMAT_ASTC_10x8_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x10_UNORM_BLOCK, "VK_FORMAT_ASTC_10x10_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x10_SRGB_BLOCK, "VK_FORMAT_ASTC_10x10_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_12x10_UNORM_BLOCK, "VK_FORMAT_ASTC_12x10_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_12x10_SRGB_BLOCK, "VK_FORMAT_ASTC_12x10_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_12x12_UNORM_BLOCK, "VK_FORMAT_ASTC_12x12_UNORM_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_12x12_SRGB_BLOCK, "VK_FORMAT_ASTC_12x12_SRGB_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_G8B8G8R8_422_UNORM, "VK_FORMAT_G8B8G8R8_422_UNORM");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8G8_422_UNORM, "VK_FORMAT_B8G8R8G8_422_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM, "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G8_B8R8_2PLANE_420_UNORM, "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM, "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G8_B8R8_2PLANE_422_UNORM, "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM, "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM");
	AddLuaGlobalInt(VK_FORMAT_R10X6_UNORM_PACK16, "VK_FORMAT_R10X6_UNORM_PACK16");
	AddLuaGlobalInt(VK_FORMAT_R10X6G10X6_UNORM_2PACK16, "VK_FORMAT_R10X6G10X6_UNORM_2PACK16");
	AddLuaGlobalInt(VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16, "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16");
	AddLuaGlobalInt(VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16, "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16");
	AddLuaGlobalInt(VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16, "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16, "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16, "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_R12X4_UNORM_PACK16, "VK_FORMAT_R12X4_UNORM_PACK16");
	AddLuaGlobalInt(VK_FORMAT_R12X4G12X4_UNORM_2PACK16, "VK_FORMAT_R12X4G12X4_UNORM_2PACK16");
	AddLuaGlobalInt(VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16, "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16");
	AddLuaGlobalInt(VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16, "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16");
	AddLuaGlobalInt(VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16, "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16, "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16, "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_G16B16G16R16_422_UNORM, "VK_FORMAT_G16B16G16R16_422_UNORM");
	AddLuaGlobalInt(VK_FORMAT_B16G16R16G16_422_UNORM, "VK_FORMAT_B16G16R16G16_422_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM, "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G16_B16R16_2PLANE_420_UNORM, "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM, "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G16_B16R16_2PLANE_422_UNORM, "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM, "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G8_B8R8_2PLANE_444_UNORM, "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16, "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16, "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16");
	AddLuaGlobalInt(VK_FORMAT_G16_B16R16_2PLANE_444_UNORM, "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM");
	AddLuaGlobalInt(VK_FORMAT_A4R4G4B4_UNORM_PACK16, "VK_FORMAT_A4R4G4B4_UNORM_PACK16");
	AddLuaGlobalInt(VK_FORMAT_A4B4G4R4_UNORM_PACK16, "VK_FORMAT_A4B4G4R4_UNORM_PACK16");
	AddLuaGlobalInt(VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK, "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK, "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK, "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK, "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK, "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK, "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK, "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK, "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK, "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK, "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK, "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK, "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK, "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK, "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK");
	AddLuaGlobalInt(VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG, "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG");
	AddLuaGlobalInt(VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG, "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG");
	AddLuaGlobalInt(VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG, "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG");
	AddLuaGlobalInt(VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG, "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG");
	AddLuaGlobalInt(VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG, "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG");
	AddLuaGlobalInt(VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG, "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG");
	AddLuaGlobalInt(VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG, "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG");
	AddLuaGlobalInt(VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG, "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG");
	AddLuaGlobalInt(VK_FORMAT_R16G16_SFIXED5_NV, "VK_FORMAT_R16G16_SFIXED5_NV");
	AddLuaGlobalInt(VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR, "VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_A8_UNORM_KHR, "VK_FORMAT_A8_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT");
	AddLuaGlobalInt(VK_FORMAT_G8B8G8R8_422_UNORM_KHR, "VK_FORMAT_G8B8G8R8_422_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_B8G8R8G8_422_UNORM_KHR, "VK_FORMAT_B8G8R8G8_422_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR, "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR, "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR, "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR, "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR, "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_R10X6_UNORM_PACK16_KHR, "VK_FORMAT_R10X6_UNORM_PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR, "VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR, "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR, "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR, "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR, "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR, "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_R12X4_UNORM_PACK16_KHR, "VK_FORMAT_R12X4_UNORM_PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR, "VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR, "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR, "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR, "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR, "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR, "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR");
	AddLuaGlobalInt(VK_FORMAT_G16B16G16R16_422_UNORM_KHR, "VK_FORMAT_G16B16G16R16_422_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_B16G16R16G16_422_UNORM_KHR, "VK_FORMAT_B16G16R16G16_422_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR, "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR, "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR, "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR, "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR, "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR");
	AddLuaGlobalInt(VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT, "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT");
	AddLuaGlobalInt(VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT, "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT");
	AddLuaGlobalInt(VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT, "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT");
	AddLuaGlobalInt(VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT, "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT");
	AddLuaGlobalInt(VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT, "VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT");
	AddLuaGlobalInt(VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT, "VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT");

	AddLuaGlobalInt(VK_IMAGE_TYPE_1D, "VK_IMAGE_TYPE_1D");
	AddLuaGlobalInt(VK_IMAGE_TYPE_2D, "VK_IMAGE_TYPE_2D");
	AddLuaGlobalInt(VK_IMAGE_TYPE_3D, "VK_IMAGE_TYPE_3D");

	AddLuaGlobalInt(VK_IMAGE_VIEW_TYPE_1D, "VK_IMAGE_VIEW_TYPE_1D");
	AddLuaGlobalInt(VK_IMAGE_VIEW_TYPE_2D, "VK_IMAGE_VIEW_TYPE_2D");
	AddLuaGlobalInt(VK_IMAGE_VIEW_TYPE_3D, "VK_IMAGE_VIEW_TYPE_3D");
	AddLuaGlobalInt(VK_IMAGE_VIEW_TYPE_CUBE, "VK_IMAGE_VIEW_TYPE_CUBE");
	AddLuaGlobalInt(VK_IMAGE_VIEW_TYPE_1D_ARRAY, "VK_IMAGE_VIEW_TYPE_1D_ARRAY");
	AddLuaGlobalInt(VK_IMAGE_VIEW_TYPE_2D_ARRAY, "VK_IMAGE_VIEW_TYPE_2D_ARRAY");
	AddLuaGlobalInt(VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY");

	AddLuaGlobalInt(VK_SAMPLE_COUNT_1_BIT, "VK_SAMPLE_COUNT_1_BIT");
	AddLuaGlobalInt(VK_SAMPLE_COUNT_2_BIT, "VK_SAMPLE_COUNT_2_BIT");
	AddLuaGlobalInt(VK_SAMPLE_COUNT_4_BIT, "VK_SAMPLE_COUNT_4_BIT");
	AddLuaGlobalInt(VK_SAMPLE_COUNT_8_BIT, "VK_SAMPLE_COUNT_8_BIT");
	AddLuaGlobalInt(VK_SAMPLE_COUNT_16_BIT, "VK_SAMPLE_COUNT_16_BIT");
	AddLuaGlobalInt(VK_SAMPLE_COUNT_32_BIT, "VK_SAMPLE_COUNT_32_BIT");
	AddLuaGlobalInt(VK_SAMPLE_COUNT_64_BIT, "VK_SAMPLE_COUNT_64_BIT");

	AddLuaGlobalInt(VK_IMAGE_TILING_OPTIMAL, "VK_IMAGE_TILING_OPTIMAL");
	AddLuaGlobalInt(VK_IMAGE_TILING_LINEAR, "VK_IMAGE_TILING_LINEAR");
	AddLuaGlobalInt(VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, "VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT");

	AddLuaGlobalInt(VK_FILTER_NEAREST, "VK_FILTER_NEAREST");
	AddLuaGlobalInt(VK_FILTER_LINEAR, "VK_FILTER_LINEAR");
	AddLuaGlobalInt(VK_FILTER_CUBIC_EXT, "VK_FILTER_CUBIC_EXT");
	AddLuaGlobalInt(VK_FILTER_CUBIC_IMG, "VK_FILTER_CUBIC_IMG");

	AddLuaGlobalInt(VK_SAMPLER_ADDRESS_MODE_REPEAT, "VK_SAMPLER_ADDRESS_MODE_REPEAT");
	AddLuaGlobalInt(VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT, "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT");
	AddLuaGlobalInt(VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE");
	AddLuaGlobalInt(VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER");
	AddLuaGlobalInt(VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE, "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE");

	AddLuaGlobalInt(VK_DEPENDENCY_BY_REGION_BIT, "VK_DEPENDENCY_BY_REGION_BIT");
	AddLuaGlobalInt(VK_DEPENDENCY_DEVICE_GROUP_BIT, "VK_DEPENDENCY_DEVICE_GROUP_BIT");
	AddLuaGlobalInt(VK_DEPENDENCY_VIEW_LOCAL_BIT, "VK_DEPENDENCY_VIEW_LOCAL_BIT");
	AddLuaGlobalInt(VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT, "VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT");
	AddLuaGlobalInt(VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR, "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR");
	AddLuaGlobalInt(VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR, "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR");

	AddLuaGlobalInt(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT, "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_VERTEX_INPUT_BIT, "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT, "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT, "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_TRANSFER_BIT, "VK_PIPELINE_STAGE_TRANSFER_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_HOST_BIT, "VK_PIPELINE_STAGE_HOST_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_NONE, "VK_PIPELINE_STAGE_NONE");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT, "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT, "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR, "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT, "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV, "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT, "VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT, "VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV, "VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV, "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV, "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV, "VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV, "VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_NONE_KHR, "VK_PIPELINE_STAGE_NONE_KHR");
	AddLuaGlobalInt(VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT, "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT");

	AddLuaGlobalInt(VK_IMAGE_ASPECT_COLOR_BIT, "VK_IMAGE_ASPECT_COLOR_BIT");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_DEPTH_BIT, "VK_IMAGE_ASPECT_DEPTH_BIT");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_STENCIL_BIT, "VK_IMAGE_ASPECT_STENCIL_BIT");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_METADATA_BIT, "VK_IMAGE_ASPECT_METADATA_BIT");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_PLANE_0_BIT, "VK_IMAGE_ASPECT_PLANE_0_BIT");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_PLANE_1_BIT, "VK_IMAGE_ASPECT_PLANE_1_BIT");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_PLANE_2_BIT, "VK_IMAGE_ASPECT_PLANE_2_BIT");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_NONE, "VK_IMAGE_ASPECT_NONE");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT, "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT, "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT, "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT, "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_PLANE_0_BIT_KHR, "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_PLANE_1_BIT_KHR, "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_PLANE_2_BIT_KHR, "VK_IMAGE_ASPECT_PLANE_2_BIT_KHR");
	AddLuaGlobalInt(VK_IMAGE_ASPECT_NONE_KHR, "VK_IMAGE_ASPECT_NONE_KHR");

	AddLuaGlobalInt(VK_ACCESS_INDIRECT_COMMAND_READ_BIT, "VK_ACCESS_INDIRECT_COMMAND_READ_BIT");
	AddLuaGlobalInt(VK_ACCESS_INDEX_READ_BIT, "VK_ACCESS_INDEX_READ_BIT");
	AddLuaGlobalInt(VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT, "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT");
	AddLuaGlobalInt(VK_ACCESS_UNIFORM_READ_BIT, "VK_ACCESS_UNIFORM_READ_BIT");
	AddLuaGlobalInt(VK_ACCESS_INPUT_ATTACHMENT_READ_BIT, "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT");
	AddLuaGlobalInt(VK_ACCESS_SHADER_READ_BIT, "VK_ACCESS_SHADER_READ_BIT");
	AddLuaGlobalInt(VK_ACCESS_SHADER_WRITE_BIT, "VK_ACCESS_SHADER_WRITE_BIT");
	AddLuaGlobalInt(VK_ACCESS_COLOR_ATTACHMENT_READ_BIT, "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT");
	AddLuaGlobalInt(VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT");
	AddLuaGlobalInt(VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT");
	AddLuaGlobalInt(VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT");
	AddLuaGlobalInt(VK_ACCESS_TRANSFER_READ_BIT, "VK_ACCESS_TRANSFER_READ_BIT");
	AddLuaGlobalInt(VK_ACCESS_TRANSFER_WRITE_BIT, "VK_ACCESS_TRANSFER_WRITE_BIT");
	AddLuaGlobalInt(VK_ACCESS_HOST_READ_BIT, "VK_ACCESS_HOST_READ_BIT");
	AddLuaGlobalInt(VK_ACCESS_HOST_WRITE_BIT, "VK_ACCESS_HOST_WRITE_BIT");
	AddLuaGlobalInt(VK_ACCESS_MEMORY_READ_BIT, "VK_ACCESS_MEMORY_READ_BIT");
	AddLuaGlobalInt(VK_ACCESS_MEMORY_WRITE_BIT, "VK_ACCESS_MEMORY_WRITE_BIT");
	AddLuaGlobalInt(VK_ACCESS_NONE, "VK_ACCESS_NONE");
	AddLuaGlobalInt(VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT, "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT");
	AddLuaGlobalInt(VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT, "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT");
	AddLuaGlobalInt(VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT, "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT");
	AddLuaGlobalInt(VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT, "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT");
	AddLuaGlobalInt(VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT, "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT");
	AddLuaGlobalInt(VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR, "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR");
	AddLuaGlobalInt(VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR, "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR");
	AddLuaGlobalInt(VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT, "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT");
	AddLuaGlobalInt(VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR, "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR");
	AddLuaGlobalInt(VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV, "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV");
	AddLuaGlobalInt(VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV, "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV");
	AddLuaGlobalInt(VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV, "VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV");
	AddLuaGlobalInt(VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV, "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV");
	AddLuaGlobalInt(VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV, "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV");
	AddLuaGlobalInt(VK_ACCESS_NONE_KHR, "VK_ACCESS_NONE_KHR");
	AddLuaGlobalInt(VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT, "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT");
	AddLuaGlobalInt(VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT, "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT");

	AddLuaGlobalInt(VK_ATTACHMENT_LOAD_OP_LOAD, "VK_ATTACHMENT_LOAD_OP_LOAD");
	AddLuaGlobalInt(VK_ATTACHMENT_LOAD_OP_CLEAR, "VK_ATTACHMENT_LOAD_OP_CLEAR");
	AddLuaGlobalInt(VK_ATTACHMENT_LOAD_OP_DONT_CARE, "VK_ATTACHMENT_LOAD_OP_DONT_CARE");
	AddLuaGlobalInt(VK_ATTACHMENT_LOAD_OP_NONE_KHR, "VK_ATTACHMENT_LOAD_OP_NONE_KHR");
	AddLuaGlobalInt(VK_ATTACHMENT_LOAD_OP_NONE_EXT, "VK_ATTACHMENT_LOAD_OP_NONE_EXT");

	AddLuaGlobalInt(VK_ATTACHMENT_STORE_OP_STORE, "VK_ATTACHMENT_STORE_OP_STORE");
	AddLuaGlobalInt(VK_ATTACHMENT_STORE_OP_DONT_CARE, "VK_ATTACHMENT_STORE_OP_DONT_CARE");
	AddLuaGlobalInt(VK_ATTACHMENT_STORE_OP_NONE, "VK_ATTACHMENT_STORE_OP_NONE");
	AddLuaGlobalInt(VK_ATTACHMENT_STORE_OP_NONE_KHR, "VK_ATTACHMENT_STORE_OP_NONE_KHR");
	AddLuaGlobalInt(VK_ATTACHMENT_STORE_OP_NONE_QCOM, "VK_ATTACHMENT_STORE_OP_NONE_QCOM");
	AddLuaGlobalInt(VK_ATTACHMENT_STORE_OP_NONE_EXT, "VK_ATTACHMENT_STORE_OP_NONE_EXT");

	AddLuaGlobalInt(VK_IMAGE_USAGE_TRANSFER_SRC_BIT, "VK_IMAGE_USAGE_TRANSFER_SRC_BIT");
	AddLuaGlobalInt(VK_IMAGE_USAGE_TRANSFER_DST_BIT, "VK_IMAGE_USAGE_TRANSFER_DST_BIT");
	AddLuaGlobalInt(VK_IMAGE_USAGE_SAMPLED_BIT, "VK_IMAGE_USAGE_SAMPLED_BIT");
	AddLuaGlobalInt(VK_IMAGE_USAGE_STORAGE_BIT, "VK_IMAGE_USAGE_STORAGE_BIT");
	AddLuaGlobalInt(VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT");
	AddLuaGlobalInt(VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT");
	AddLuaGlobalInt(VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT");
	AddLuaGlobalInt(VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT");
	AddLuaGlobalInt(VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR, "VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR");
	AddLuaGlobalInt(VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR, "VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR");
	AddLuaGlobalInt(VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, "VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR");
	AddLuaGlobalInt(VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT");
	AddLuaGlobalInt(VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, "VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR");
	AddLuaGlobalInt(VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT, "VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT");
	AddLuaGlobalInt(VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR, "VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR");
	AddLuaGlobalInt(VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR, "VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR");
	AddLuaGlobalInt(VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR, "VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR");
	AddLuaGlobalInt(VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT, "VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT");
	AddLuaGlobalInt(VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI, "VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI");
	AddLuaGlobalInt(VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM, "VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM");
	AddLuaGlobalInt(VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM, "VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM");
	AddLuaGlobalInt(VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, "VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV");

	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_SAMPLER, "VK_DESCRIPTOR_TYPE_SAMPLER");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, "VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, "VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_MUTABLE_EXT, "VK_DESCRIPTOR_TYPE_MUTABLE_EXT");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT");
	AddLuaGlobalInt(VK_DESCRIPTOR_TYPE_MUTABLE_VALVE, "VK_DESCRIPTOR_TYPE_MUTABLE_VALVE");

	AddLuaGlobalInt(VK_CULL_MODE_NONE, "VK_CULL_MODE_NONE");
	AddLuaGlobalInt(VK_CULL_MODE_FRONT_BIT, "VK_CULL_MODE_FRONT_BIT");
	AddLuaGlobalInt(VK_CULL_MODE_BACK_BIT, "VK_CULL_MODE_BACK_BIT");
	AddLuaGlobalInt(VK_CULL_MODE_FRONT_AND_BACK, "VK_CULL_MODE_FRONT_AND_BACK");

	AddLuaGlobalInt(this->backend->renderFormat, "RenderFmt");
	AddLuaGlobalInt(this->backend->postProcessingFormat, "PresentFmt");
	AddLuaGlobalInt(this->backend->swapChainImageFormat, "SwapChainFmt");
	AddLuaGlobalInt(this->backend->normalFormat, "NormalFmt");
	AddLuaGlobalInt(this->backend->positionFormat, "PositionFmt");
	AddLuaGlobalInt(this->backend->GIFormat, "GIFmt");
	AddLuaGlobalInt(this->backend->findDepthFormat(), "DepthFmt");
	AddLuaGlobalInt(this->backend->findDepthStencilFormat(), "DepthStencilFmt");

	Lua_PushTexture_NoGC(L, &backend->cubemap, backend->cubemap.Width, backend->cubemap.Height);
	lua_setglobal(L, "Cubemap");

	Lua_PushTexture_NoGC(L, &backend->skyCubeMap, backend->skyCubeMap.Width, backend->skyCubeMap.Height);
	lua_setglobal(L, "SkyCubemap");

	Lua_PushTexture_NoGC(L, &backend->mainRenderTarget_C, backend->mainRenderTarget_C.Width, backend->mainRenderTarget_C.Height);
	lua_setglobal(L, "mainRenderTarget_C");

	Lua_PushTexture_NoGC(L, &backend->mainRenderTarget_N, backend->mainRenderTarget_N.Width, backend->mainRenderTarget_N.Height);
	lua_setglobal(L, "mainRenderTarget_N");

	Lua_PushTexture_NoGC(L, &backend->mainRenderTarget_P, backend->mainRenderTarget_P.Width, backend->mainRenderTarget_P.Height);
	lua_setglobal(L, "mainRenderTarget_P");

	Lua_PushTexture_NoGC(L, &backend->mainRenderTarget_D, backend->mainRenderTarget_D.Width, backend->mainRenderTarget_D.Height);
	lua_setglobal(L, "mainRenderTarget_D");

	Lua_PushTexture_NoGC(L, &backend->mainRenderTarget_G, backend->mainRenderTarget_G.Width, backend->mainRenderTarget_G.Height);
	lua_setglobal(L, "mainRenderTarget_G");

	Lua_PushTexture_NoGC(L, &backend->RTTexture, backend->RTTexture.Width, backend->RTTexture.Height);
	lua_setglobal(L, "RTTexture");

	AddLuaGlobalInt(SF_DEFAULT, "SF_DEFAULT");
	AddLuaGlobalInt(SF_ALPHA, "SF_ALPHA");
	AddLuaGlobalInt(SF_POSTPROCESS, "SF_POSTPROCESS");
	AddLuaGlobalInt(SF_SKYBOX, "SF_SKYBOX");
	AddLuaGlobalInt(SF_SHADOW, "SF_SHADOW");
	AddLuaGlobalInt(SF_SUNSHADOWPASS, "SF_SUNSHADOWPASS");
	AddLuaGlobalInt(SF_SPOTSHADOWPASS, "SF_SPOTSHADOWPASS");

	AddLuaGlobalInt(BM_OPAQUE, "BM_OPAQUE");
	AddLuaGlobalInt(BM_TRANSPARENT, "BM_TRANSPARENT");
	AddLuaGlobalInt(BM_ADDITIVE, "BM_ADDITIVE");
	AddLuaGlobalInt(BM_MAX, "BM_MAX");

	AddLuaGlobalInt(this->backend->swapChainExtent.width, "SwapChainWidth");
	AddLuaGlobalInt(this->backend->swapChainExtent.height, "SwapChainHeight");

	AddLuaGlobalUData(this, "App");
	AddLuaGlobalUData(&this->backend->swapChainExtent, "Extent");
	AddLuaGlobalUData(this->backend->physicalDevice, "GPU");


	if (luaL_dofile(L, "engine.lua"))
	{
		PrintF("Failed to load and run script! %s\n", lua_tostring(L, -1));
		lua_pop(L, 1);
		throw std::runtime_error("Failed to run engine.lua!");
	}


	lua_getglobal(L, "lightResultRenderPass");
		this->backend->sunShadowPassRenderPass = Lua_GetRenderPass(L, -1)->renderPass;
	lua_pop(L, 1);

	lua_getglobal(L, "spotShadowPassRenderPass");
		this->backend->spotShadowPassRenderPass = Lua_GetRenderPass(L, -1)->renderPass;
	lua_pop(L, 1);

	lua_getglobal(L, "SampleCount");
		this->backend->msaaSamples = (VkSampleCountFlagBits)lua_tointeger(L, -1);
	lua_pop(L, 1);

	this->backend->CreateShadowPassPipeline();

	Lua_AddGLFWLib(L, glWindow);
	Lua_AddGLMLib(L);

	lua_pushlightuserdata(L, this);
	lua_pushcclosure(L, LuaFN_LoadLevelFromFile, 1);
	lua_setglobal(L, "LoadLevelFromFile");

	lua_pushcclosure(L, LuaFN_NewCamera, 0);
	lua_setglobal(L, "NewCamera");

	lua_pushcclosure(L, LuaFN_GetActiveCamera, 0);
	lua_setglobal(L, "GetActiveCamera");

	lua_pushcclosure(L, LuaFN_SetActiveCamera, 0);
	lua_setglobal(L, "SetActiveCamera");

	lua_pushcclosure(L, LuaFN_DirectionFromAngle, 0);
	lua_setglobal(L, "DirFromAngle");

	lua_pushcclosure(L, LuaFN_GetObjectsById, 0);
	lua_setglobal(L, "GetObjectsById");

	lua_pushcclosure(L, LuaFN_SpawnObject, 0);
	lua_setglobal(L, "SpawnObject");

	lua_pushcclosure(L, LuaFN_TraceRay, 0);
	lua_setglobal(L, "TraceRay");

	lua_pushcclosure(L, LuaFN_NewFloat3, 0);
	lua_setglobal(L, "float3");

	lua_pushcclosure(L, LuaFN_MoveObjectTo, 0);
	lua_setglobal(L, "MoveObjectTo");


	if (luaL_dofile(L, "Game.lua"))
	{
		PrintF("Failed to do Game.lua: %s\n", lua_tostring(L, -1));
		lua_pop(L, 1);
	}


	lua_getglobal(L, "GameBegin");
#ifdef LUA_PROTECTCALL
	if (lua_pcall(L, 0, 0, 0))
	{
		PrintF("Failed to GameBegin: %s\n", lua_tostring(L, -1));
		lua_pop(L, 1);
	}
#else
	lua_call(L, 0, 0);
#endif

	//backend->ReadRenderProcess(L);
}

#define NEW(type) (type*)malloc(sizeof(type))


void VulkanEngine::DrawGUI(VkCommandBuffer commandBuffer)
{
	ImGui::Render();
	ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), commandBuffer);
}

void VulkanEngine::StartShaderCompileThread()
{
	threadAwaitingSync = false;
	threadSynced = false;

	shaderCompileThread = new Thread(RecompileShaderThreadProc, glWindow);
}

void VulkanEngine::EndShaderCompileThread()
{
	if (shaderCompileThread)
	{
		delete shaderCompileThread;
		shaderCompileThread = NULL;
	}
}

void VulkanEngine::RenderGUI()
{
	// GUI
	ImGui_ImplVulkan_NewFrame();
	ImGui_ImplGlfw_NewFrame();
	ImGui::NewFrame();

	if (showConsole)
	{
		ImGui::Begin("Console");
		ImGui::BeginChild("ConsoleOutput", ImVec2(consoleWidth, 256), ImGuiChildFlags_Borders);
		for (const char* line : consoleOutput)
			ImGui::Text(line);
		ImGui::EndChild();
		if (ImGui::InputText("Command", consoleBuffer, 64, ImGuiInputTextFlags_EnterReturnsTrue))
		{
			InterpretConsoleCommand();
			consoleOutput.push_back("Test Line");
		}
		ImGui::End();
	}

	ImGui::Begin("Profiler");

	float waitTimeMS = waitTime / 1000.f;
	float totalTime = backend->stats.frametime + waitTimeMS;
	float gpuTimeMS = gpuTime / 1000.f;

	size_t effectiveFrameRate = (size_t)roundf(1000.f / totalTime);

	ImGui::Text("%zi FPS", effectiveFrameRate);
	ImGui::Text("Total Frame Time: %fms", totalTime);
	ImGui::Text("Total CPU Time: %fms", backend->stats.frametime - gpuTimeMS);
	ImGui::Text("\tAcquire Time: %fms", backend->acquireTime / 1000.f);
	ImGui::Text("\tSetup Render: %fms", backend->setupRenderTime / 1000.f);
	ImGui::Text("\tCommand Buffer Record Time: %fms", backend->recordTime / 1000.f);
	ImGui::Text("\tLua: %fms", luaTime / 1000.f);
	ImGui::Text("Wait Time: %fms", waitTimeMS);
	ImGui::Text("Present Time: %fms", backend->presentTime / 1000.f);
	ImGui::Text("Fence Wait: %fms", gpuTimeMS);

	/*
	ImGui::Text("%i Render Passes", stats.passes);
	ImGui::Text("%i vkCmdBindPipeline\'s", stats.bound_pipelines);
	ImGui::Text("%i Blits", stats.blits);
	ImGui::Text("%i Draw Calls", stats.drawcall_count);
	ImGui::Text("%i API Calls Total", stats.api_calls);

	ImGui::Text("%i Triangles", stats.triangle_count);
	*/
	int maxFps = maxFPS;
	ImGui::DragInt("Max FPS", &maxFps);
	if (maxFps != maxFPS && maxFps > 0)
	{
		maxFPS = maxFps;
		FPSToFrametime();
	}

	if (ImGui::Button("Add SpotLight"))
	{
		float3 dir = glm::normalize(backend->GetActiveCamera()->target - backend->GetActiveCamera()->position);
		backend->AddSpotLight(backend->GetActiveCamera()->position, dir, glm::radians(90.f), 100.f);
	}

	if (backend->numSpotLights)
	{
		if (ImGui::Button("Spot Light Controls"))
			showSpotLightControls = !showSpotLightControls;

		if (showSpotLightControls)
		{
			ImGui::InputInt("Selected SpotLight Index", &selectedSpotLight, 1, 5);
			if (selectedSpotLight < 0)
				selectedSpotLight = 0;

			if (selectedSpotLight >= backend->numSpotLights)
				selectedSpotLight = backend->numSpotLights - 1;

			ImGui::DragFloat3("LightDir", (float*)&backend->allSpotLights[selectedSpotLight]->dir, 0.01f, -1.0f, 1.0f);
			(float3&)backend->allSpotLights[selectedSpotLight]->dir = glm::normalize((float3)backend->allSpotLights[selectedSpotLight]->dir);
			ImGui::DragFloat3("LightPos", (float*)&backend->allSpotLights[selectedSpotLight]->position, 0.1f, -1000.f, 1000.f);
			ImGui::DragFloat("LightFOV", &backend->allSpotLights[selectedSpotLight]->dir.a, 0.1f, 0.0f, glm::radians(180.f));
			ImGui::DragFloat("Attenuation", &backend->allSpotLights[selectedSpotLight]->position.a, 0.1f, 0.0f, 5000.f);

			backend->allSpotLights[selectedSpotLight]->UpdateMatrix(NULL, backend->currentFrame);
		}
	}

	if (backend->theSun)
	{
		if (ImGui::Button("Sun Light Controls"))
		{
			showSunLightControls = !showSunLightControls;
		}

		if (showSunLightControls)
		{
			ImGui::DragFloat("Sun Down Angle", &backend->sunDownAngle, 0.01f);
			ImGui::DragFloat("Sun Swing Speed", &backend->sunSwingSpeed, 0.01f);

			char cascadeIDBuffer[16];
			for (uint32_t i = 0; i < NUMCASCADES; i++)
			{
				ZEROMEM(cascadeIDBuffer, 16);
				sprintf(cascadeIDBuffer, "Sun Dist %u", i);
				ImGui::DragFloat(cascadeIDBuffer, &backend->theSun->cascadeDistances[i], 0.01f);
			}

			backend->theSun->UpdateProjection();
		}
	}
	else
	{
		if (ImGui::Button("Add Sun Light"))
		{
			backend->theSun = new SunLight(float3(0.0, 0.7, 0.7), SHADOWMAPSIZE, SHADOWMAPSIZE, backend);
			backend->RefreshCommandBufferRefs();
			backend->RecordPostProcessCommandBuffers();
		}
	}

	ImGui::End();
}

int focused = VK_TRUE;

void VulkanEngine::PerFrame()
{
	if (threadAwaitingSync)
	{
		threadSynced = true;
		return;
	}

	glfwPollEvents();

	focused = glfwGetWindowAttrib(glWindow, GLFW_FOCUSED);
	if (!focused) return;


	auto now = std::chrono::high_resolution_clock::now();
	auto delta = std::chrono::duration_cast<std::chrono::microseconds>(now - start).count();

	if (delta > minFrametime)
	{
		waitTime = std::chrono::duration_cast<std::chrono::microseconds>(now - waitStart).count();
		start = now;

		auto luaStart = std::chrono::high_resolution_clock::now();
		lua_getglobal(L, "GameTick");
		lua_pushnumber(L, delta);
		lua_pushboolean(L, locked);
#ifdef LUA_PROTECTCALL
		if (lua_pcall(L, 2, 0, 0))
		{
			PrintF("Failed to GameTick: %s\n", lua_tostring(L, -1));
			lua_pop(L, 1);
		}
#else
		lua_call(L, 2, 0);
#endif
		auto luaEnd = std::chrono::high_resolution_clock::now();
		luaTime = std::chrono::duration_cast<std::chrono::microseconds>(luaEnd - luaStart).count();

		backend->GetActiveCamera()->UpdateMatrix(&backend->perspectiveMatrix);
		RenderGUI();

		backend->PerFrame();

		waitStart = std::chrono::high_resolution_clock::now();
		auto frameelapsed = std::chrono::duration_cast<std::chrono::microseconds>(waitStart - now);
		backend->stats.frametime = frameelapsed.count() / 1000.f;
		//break;
	}
}

void VulkanEngine::FPSToFrametime()
{
	minFrametime = (size_t)1000000 / (size_t)maxFPS;
}

VulkanEngine::VulkanEngine()
{
	glWindow = NULL;
	g_App = this;

	INI_UInt32("screenWidth", &Width);
	INI_UInt32("screenHeight", &Height);
	INI_Int("maxFPS", &maxFPS);
	ReadINIFile("engine.ini");

	FPSToFrametime();

	InitWindow();

	backend = new VulkanBackend(glWindow, DrawGUI);

	InitLua();
	InitGUI();

	start = std::chrono::high_resolution_clock::now();
	waitStart = std::chrono::high_resolution_clock::now();

	StartShaderCompileThread();
}

MeshObject* VulkanEngine::AddObject(float3 position, float3 rotation, float3 scale, Mesh* mesh, Texture* shadowMap, bool isStatic, bool castsShadows, BYTE id)
{
	return backend->AddObject(position, rotation, scale, mesh, shadowMap, isStatic, castsShadows, id);
}

void VulkanEngine::Run()
{
	backend->RefreshCommandBufferRefs();
	backend->SetupObjects();
	backend->RecordPostProcessCommandBuffers();
	backend->updateUniformBufferDescriptorSets();

	while (!glfwWindowShouldClose(glWindow))
		PerFrame();
}

VulkanEngine::~VulkanEngine()
{
	//delete pollThread;
	EndShaderCompileThread();

	vkDeviceWaitIdle(this->backend->logicalDevice);

	lua_close(L);
	DeInitGUI();
	backend->UnloadLevel();

	delete backend;

	for (const auto i : allBuffers)
	{
		if (!i->destroyed)
		{
			PrintF("Buffer has not been destroyed from %s\n", i->origin);
		}
	}

	DeInitWindow();
}

static void PrintMeshObject(MeshObject* mo)
{
	PrintF("Mesh Object: (%f, %f, %f) [%f, %f, %f], {%f, %f, %f}\n", mo->position.x, mo->position.y, mo->position.z, mo->rotation.x, mo->rotation.y, mo->rotation.z, mo->scale.x, mo->scale.y, mo->scale.z);
}

static VkCullModeFlagBits CullModeFromString(char* str)
{
	switch (*(str + 13))
	{
		case 'N':
			return VK_CULL_MODE_NONE;

		case 'F':
			return VK_CULL_MODE_FRONT_BIT;

		default:
			return VK_CULL_MODE_BACK_BIT;
	}
}

static VkPolygonMode PolygonModeFromString(char* str)
{
	switch (*(str + 17))
	{
		case 'P':
			return VK_POLYGON_MODE_POINT;

		case 'L':
			return VK_POLYGON_MODE_LINE;

		default:
			return VK_POLYGON_MODE_FILL;
	}
}

static BlendMode BlendModeFromString(char* str)
{
	switch (*(str + 3))
	{
		case 'A':
			return BM_ADDITIVE;

		case 'T':
			return BM_TRANSPARENT;

		default:
			return BM_OPAQUE;
	}
}

Shader* VulkanEngine::ReadMaterialFile(const char* filename)
{
	auto mat = readFile(filename);

	char* ptr = mat.data();
	char* end = ptr + mat.size();

	char* zlsl = (char*)malloc(32);
	ZEROMEM(zlsl, 32);
	ptr = ReadSnippet(ptr, end, zlsl);

	char* vs = (char*)malloc(32);
	ZEROMEM(vs, 32);
	ptr = ReadSnippet(ptr, end, vs);

	char* ps = (char*)malloc(32);
	ZEROMEM(ps, 32);
	ptr = ReadSnippet(ptr, end, ps);

	char buffer[32];
	ZEROMEM(buffer, 32);
	ptr = ReadSnippet(ptr, end, buffer);

	VkCullModeFlagBits cullMode = CullModeFromString(buffer);

	ZEROMEM(buffer, 32);
	ptr = ReadSnippet(ptr, end, buffer);
	VkPolygonMode polygonMode = PolygonModeFromString(buffer);


	ZEROMEM(buffer, 32);
	ptr = ReadSnippet(ptr, end, buffer);
	BlendMode alphaBlend = BlendModeFromString(buffer);
	ZEROMEM(buffer, 32);
	ptr = ReadSnippet(ptr, end, buffer);
	bool depthTest = !strcmp(buffer, "true");
	ZEROMEM(buffer, 32);
	ptr = ReadSnippet(ptr, end, buffer);
	bool depthWrite = !strcmp(buffer, "true");

	ZEROMEM(buffer, 32);
	ptr = ReadSnippet(ptr, end, buffer);
	bool masked = !strcmp(buffer, "true");

	ZEROMEM(buffer, 32);
	ptr = ReadSnippet(ptr, end, buffer);
	uint32_t stencilWriteMask = atoi(buffer);

	size_t numVBuffers, numPBuffers, numSamplers, numVPBOs, numPPBOs, numAttachments;
	char* outVShader = NULL;
	GetInfoFromZLSL(zlsl, &numSamplers, &numVBuffers, &numPBuffers, &numVPBOs, &numPPBOs, &numAttachments, &outVShader);
	if (outVShader) free(outVShader);

	VkDescriptorSetLayout* setLayout = backend->GetDescriptorSetLayout(numVBuffers, numPBuffers, numSamplers);
	Shader* pipeline = this->backend->NewPipeline_Separate(zlsl, ps, true, vs, true, backend->mainRenderPass, SF_DEFAULT, this->backend->swapChainExtent, cullMode, polygonMode, this->backend->msaaSamples, alphaBlend, stencilWriteMask, VK_COMPARE_OP_EQUAL, 0, 0.0f, depthTest, depthWrite, masked);
	return pipeline;
}


bool VulkanEngine::RayObjects(float3 rayOrigin, float3 rayDir, int id, MeshObject** outObject, float* outDst)
{
	float3 coords;
	*outDst = 99999999.f;
	float currentDst = 0;
	*outObject = NULL;
	bool hit = false;

	for (size_t i = 0; i < backend->allObjectsLen; i++)
	{
		if (backend->allObjects[i]->id != id) continue;

		if (RayBox(rayOrigin, rayDir, backend->allObjects[i]->mesh->boundingBoxCentre, backend->allObjects[i]->mesh->boundingBoxMax - backend->allObjects[i]->mesh->boundingBoxMin, coords))
		{
			currentDst = glm::distance(coords, rayOrigin);
			if (currentDst < *outDst)
			{
				hit = true;

				*outObject = backend->allObjects[i];
				*outDst = currentDst;
			}
		}
	}

	return hit;
}


#define IncReadAs(x, type) *(type*)x; x += sizeof(type)

char* VulkanEngine::AddFolder(const char* folder, const char* filename)
{
	int l = strlen(filename) + strlen(folder);
	char* ptr = (char*)malloc(l + 1);
	check(ptr, "AddFolder: Failed to allocate filename buffer!");
	ZEROMEM(ptr, l);
	StringCopySafe(ptr, l + 1, folder);
	StringConcatSafe(ptr, l + 1, filename);
	return ptr;
}

char* VulkanEngine::Concat(const char** strings, size_t numStrings)
{
	char* concatBuffer = (char*)malloc(128);
	ZEROMEM(concatBuffer, 128);
	StringCopySafe(concatBuffer, 128, strings[0]);
	for (size_t i = 1; i < numStrings; i++)
		StringConcatSafe(concatBuffer, 128, strings[i]);

	return concatBuffer;
}


void VulkanEngine::LoadLevel_FromFile(const char* filename)
{
	if (levelLoaded)
	{
		EndShaderCompileThread();
		backend->UnloadLevel();
	}

	char filenamebuffer[256];
	StringCopy(filenamebuffer, (char*)"levels/", 8);
	StringConcatSafe(filenamebuffer, 256, filename);
	StringConcatSafe(filenamebuffer, 256, "/");
	StringConcatSafe(filenamebuffer, 256, filename);
	StringConcatSafe(filenamebuffer, 256, ".lvl");

	backend->CreateCubemap("textures/cubemap", &this->backend->cubemap);
	backend->CreateCubemap("textures/skycube", &this->backend->skyCubeMap);

	auto data = readFile(filenamebuffer);

	int preExisting = this->backend->numPipelines;

	printf("\tLoading Built-in Shaders...\n");
	for (const LevelData_Shader& i : shaders)
		this->backend->NewPipeline_Separate(i.zlslFilename, i.pixelShaderFilename, false, i.vertexShaderFilename, false, backend->mainRenderPass, i.shaderType, this->backend->swapChainExtent, i.cullMode, i.polygonMode, this->backend->msaaSamples, i.alphaBlending, 0, VK_COMPARE_OP_EQUAL, 0, 0.0f, i.depthTest, i.depthWrite, i.masked);

	printf("\tDone!\n");

	char* ptr = data.data();

	float3 pos, rot, dir;
	float fov;
	float4x4 matrix;

	if (*ptr++)
	{
		rot.x = IncReadAs(ptr, float);
		rot.y = IncReadAs(ptr, float);
		rot.z = IncReadAs(ptr, float);

		matrix = WorldMatrix(float3(0), rot, float3(1));

		backend->theSun = new SunLight(matrix * float4(0, 0, -1, 0), SHADOWMAPSIZE, SHADOWMAPSIZE, this->backend);
	}

	uint16_t length = IncReadAs(ptr, uint16_t);

	for (uint16_t i = 0; i < length; i++)
	{
		pos.x = IncReadAs(ptr, float);
		pos.y = IncReadAs(ptr, float);
		pos.z = IncReadAs(ptr, float);

		rot.x = IncReadAs(ptr, float);
		rot.y = IncReadAs(ptr, float);
		rot.z = IncReadAs(ptr, float);

		matrix = WorldMatrix(float3(0), rot, float3(1));

		fov = IncReadAs(ptr, float);
		dir = matrix * float4(0, 0, -1, 0);
		backend->AddSpotLight(pos, dir, fov, 500.f);
	}

	length = *(uint16_t*)ptr;
	ptr += sizeof(uint16_t);

	const char* strings[3] = { "materials/", "", ".mat" };

	printf("\tLoading Level Shaders...\n");
	for (uint16_t i = 0; i < length; i++)
	{
		strings[1] = data.data() + *(unsigned int*)ptr;
		const char* filename = Concat(strings, 3);
		ReadMaterialFile(filename);
		ptr += sizeof(unsigned int);
	}
	printf("\tDone!\n");


	length = *(uint16_t*)ptr;
	ptr += sizeof(uint16_t);

	uint32_t matIndex;

	bool isNew = false;

	VkDescriptorSetLayout setLayouts[2] = {
		VK_NULL_HANDLE,
		*backend->GetDescriptorSetLayout(0, 0, 1)
	};

	printf("\tLoading Materials...\n");
	uint16_t preExistingMaterials = backend->allMaterials.size();
	backend->allMaterials.resize(preExistingMaterials + length);
	// materials
	for (uint16_t i = 0; i < length; i++)
	{
		matIndex = i + preExistingMaterials;

		BYTE pipelineDex = *(BYTE*)ptr++;

		backend->allMaterials[matIndex].shader = &this->backend->allPipelines[pipelineDex + preExisting];
		backend->allMaterials[matIndex].masked = backend->allMaterials[matIndex].shader->masked;

		backend->allMaterials[matIndex].textures = {};

		BYTE numFilenames = *(BYTE*)ptr++;

		for (BYTE j = 0; j < numFilenames; j++)
		{
			if (j != 1)
				backend->allMaterials[matIndex].textures.push_back(LoadTexture(data.data() + *(unsigned int*)ptr, false, false, NULL));

			ptr += sizeof(unsigned int);
		}

		VkDescriptorSetAllocateInfo allocateInfo{};
		allocateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;

		setLayouts[0] = *backend->GetDescriptorSetLayout(0, 0, backend->allMaterials[matIndex].shader->shaderType == SF_SKYBOX ? 2 : numFilenames + 2);

		allocateInfo.pSetLayouts = setLayouts;
		allocateInfo.descriptorSetCount = 2;
		allocateInfo.descriptorPool = this->backend->descriptorPool;
		allocateInfo.pNext = VK_NULL_HANDLE;
		vkAllocateDescriptorSets(this->backend->logicalDevice, &allocateInfo, backend->allMaterials[matIndex].descriptorSets);

		updateMaterialDescriptorSets(&backend->allMaterials[matIndex]);

		backend->allMaterials[matIndex].roughness = IncReadAs(ptr, float);
	}
	printf("\tDone!\n");

	length = IncReadAs(ptr, uint16_t);

	char* filenameBuffer;
	int l;
	strings[0] = "models/";
	strings[2] = ".msh";
	printf("\tLoading Meshes...\n");
	BYTE numMexels;

	for (uint16_t i = 0; i < length; i++)
	{
		backend->allMeshes.push_back(new Mesh());
		numMexels = *ptr++;
		backend->allMeshes.back()->mexels.resize(numMexels);
		for (BYTE j = 0; j < numMexels; j++)
		{
			strings[1] = ptr;
			backend->allMeshes.back()->mexels[j] = LoadMexelFromFile(Concat(strings, 3));

			while (*ptr++);
		}
	}
	printf("\tDone!\n");

	length = *(uint16_t*)ptr;
	ptr += sizeof(uint16_t);


	MeshObject* mo;
	Material* mat;

	uint16_t meshIndex;
	float3 scale;
	float texScale;
	BYTE numMaterials;
	std::vector<uint16_t> materialIndex = {};
	BYTE meshID;
	bool isStatic, castsShadows;
	unsigned int filenameIndex;
	Mesh* mesh;

	printf("\tLoading Objects...\n");
	for (uint16_t i = 0; i < length; i++)
	{
		meshIndex = IncReadAs(ptr, uint16_t);
		pos.x = IncReadAs(ptr, float);
		pos.y = IncReadAs(ptr, float);
		pos.z = IncReadAs(ptr, float);
		rot.x = IncReadAs(ptr, float);
		rot.y = IncReadAs(ptr, float);
		rot.z = IncReadAs(ptr, float);
		scale.x = IncReadAs(ptr, float);
		scale.y = IncReadAs(ptr, float);
		scale.z = IncReadAs(ptr, float);
		texScale = IncReadAs(ptr, float);
		numMaterials = *ptr++;
		for (BYTE j = 0; j < numMaterials; j++)
		{
			materialIndex.push_back(*(uint16_t*)ptr);
			ptr += sizeof(uint16_t);
		}

		isStatic = *(bool*)ptr++;
		castsShadows = *(bool*)ptr++;
		meshID = *(BYTE*)ptr++;
		filenameIndex = IncReadAs(ptr, unsigned int);

		mo = new MeshObject(pos, rot, scale, backend->allMeshes[meshIndex], LoadTexture(data.data() + filenameIndex, false, false, NULL), texScale, isStatic, castsShadows, meshID, NULL);

		std::cout << mo->shadowMap->freeFilename << "\n";

		mo->materials.resize(numMaterials);

		for (BYTE j = 0; j < numMaterials; j++)
			mo->materials[j] = &backend->allMaterials[materialIndex[j]];

		materialIndex.clear();
		backend->allObjects[backend->allObjectsLen++] = mo;
	}

	printf("\tDone!\n");

	backend->OnLevelLoad();

	if (levelLoaded)
	{
		for (uint32_t i = 0; i < this->backend->numPipelines; i++)
			CheckIfShaderNeedsRecompilation(&this->backend->allPipelines[i], false);

		this->backend->RefreshCommandBufferRefs();
		StartShaderCompileThread();
	}

	backend->ReadRenderProcess(L);


	//backend->RunComputeShader();

	levelLoaded = true;
}


template<typename T>
bool VulkanEngine::VectorSame(std::vector<T> v1, std::vector<T> v2)
{
	if (v1.size() == v2.size())
	{
		for (size_t i = 0; i < v1.size(); i++)
		{
			if (v1[i] != v2[i])
				return false;
		}
		return true;
	}
	return false;
}


void VulkanEngine::MakeSafeName(char* filename)
{
	while (*filename)
	{
		if (*filename == '.')
			*filename = '_';

		filename++;
	}
}

void VulkanEngine::GetDir(const char* filename, char* outDir, size_t& outLength)
{
	outLength = strlen(filename) - 1;

	while ((filename[outLength] != '/') && (outLength > 0))
		outLength--;

	// Include the ending slash, if there is one
	if (outLength)
		outLength++;

	for (size_t i = 0; i < outLength; i++)
		outDir[i] = filename[i];

}

void VulkanEngine::InitWindow()
{
	glfwInit();

	// Disable built-in OpenGL
	glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
	//glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

#ifdef ENABLE_FULLSCREEN
	glWindow = glfwCreateWindow(Width, Height, "Zack\'s Vulkan Engine", glfwGetPrimaryMonitor(), nullptr);
#else
	glWindow = glfwCreateWindow(Width, Height, "Zack\'s Vulkan Engine", nullptr, nullptr);
#endif

	GLFWimage icons[2];
	int width0, height0, comp0, width1, height1, comp1;
	iconData = stbi_load("icon.png", &width0, &height0, &comp0, 4);
	iconSmallData = stbi_load("icon-small.png", &width1, &height1, &comp1, 4);

	icons[0].width = width0;
	icons[0].height = height0;
	icons[0].pixels = (unsigned char*)iconData;

	icons[1].width = width1;
	icons[1].height = height1;
	icons[1].pixels = (unsigned char*)iconSmallData;
	glfwSetWindowIcon(glWindow, 2, icons);

	// Apparently the icon in the taskbar doesn't update unless PollEvents is called right afterwards
	glfwPollEvents();

	glfwSetKeyCallback(glWindow, key_callback);
	//glfwSetInputMode(glWindow, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
	//glfwSetInputMode(glWindow, GLFW_RAW_MOUSE_MOTION, GLFW_TRUE);
	glfwSetInputMode(glWindow, GLFW_STICKY_KEYS, GLFW_FALSE);
}

void VulkanEngine::DeInitGUI()
{
	ImGui_ImplGlfw_Shutdown();
	ImGui_ImplVulkan_Shutdown();
	ImGui::DestroyContext();
}

ImGuiContext* guiContext;
void VulkanEngine::InitGUI()
{
	IMGUI_CHECKVERSION();
	guiContext = ImGui::CreateContext();

	ImGui_ImplGlfw_InitForVulkan(glWindow, true);

	ImGui_ImplVulkan_InitInfo info{};
	info.Instance = this->backend->instance;
	info.PhysicalDevice = this->backend->physicalDevice;
	info.Device = this->backend->logicalDevice;
	info.QueueFamily = this->backend->GetGraphicsFamily();
	info.Queue = this->backend->graphicsQueue;
	info.PipelineCache = 0;
	info.DescriptorPoolSize = 2;
	info.Subpass = 0;
	info.MinImageCount = backend->MAX_FRAMES_IN_FLIGHT;
	info.ImageCount = backend->MAX_FRAMES_IN_FLIGHT;
	info.MSAASamples = VK_SAMPLE_COUNT_1_BIT;
	info.Allocator = nullptr;
	info.CheckVkResultFn = OnGUIError;

	info.RenderPass = this->backend->postProcRenderPass;

	ImGui_ImplVulkan_Init(&info);

	ImGui_ImplVulkan_CreateFontsTexture();
}

void VulkanEngine::DeInitWindow()
{
	glfwDestroyWindow(glWindow);
	glfwTerminate();
	stbi_image_free(iconData);
	stbi_image_free(iconSmallData);
}

template <typename T>

bool VulkanEngine::InVector(std::vector<T>* list, T item) {
	for (size_t i = 0; i < list->size(); i++)
	{
		if ((*list)[i] == item)
			return true;
	}
	return false;
}

void VulkanEngine::updateMaterialDescriptorSets(Material* mat)
{
	std::vector<VkWriteDescriptorSet> writes;
	std::vector<VkDescriptorImageInfo> imageInfos;

	bool isSky = mat->shader->shaderType == SF_SKYBOX;

	size_t len = mat->textures.size();
	if (isSky)
		len = 1;

	Texture* noisetexture = LoadTexture("textures/noise3.png", false, false, NULL);

	writes.resize(len + 1);
	imageInfos.resize(len + 1);

	if (!isSky)
	{
		for (size_t i = 0; i < len; i++)
		{
			imageInfos[i].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
			imageInfos[i].imageView = mat->textures[i]->View;
			imageInfos[i].sampler = mat->textures[i]->Sampler;
		}

		imageInfos[len].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
		imageInfos[len].imageView = this->backend->cubemap.View;
		imageInfos[len].sampler = this->backend->cubemap.Sampler;
	}
	else
	{
		imageInfos[0].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
		imageInfos[0].imageView = this->backend->skyCubeMap.View;
		imageInfos[0].sampler = this->backend->skyCubeMap.Sampler;

		imageInfos[1].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
		imageInfos[1].imageView = noisetexture->View;
		imageInfos[1].sampler = noisetexture->Sampler;
	}

	for (size_t i = 0; i < imageInfos.size(); i++)
	{
		writes[i].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
		writes[i].dstSet = mat->descriptorSets[0];
		writes[i].dstBinding = i;
		writes[i].dstArrayElement = 0;
		writes[i].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
		writes[i].descriptorCount = 1;
		writes[i].pImageInfo = &imageInfos[i];
	}

	vkUpdateDescriptorSets(this->backend->logicalDevice, writes.size(), writes.data(), 0, VK_NULL_HANDLE);

	writes[0].dstSet = mat->descriptorSets[1];
	vkUpdateDescriptorSets(this->backend->logicalDevice, 1, writes.data(), 0, VK_NULL_HANDLE);
}

// Gets an image from the filename
// There's an optional pointer to store whether or not the texture is new, so if the filename is allocated you can free it
Texture*& VulkanEngine::LoadTexture(const char* filename, bool isNormal, bool freeFilename, bool* out_IsNew)
{
	if (!FileExists(filename))
	{
		printf("Texture does not exist: [%s] Replacing...\n", filename);
		if (out_IsNew)
			*out_IsNew = false;
		return LoadTexture("textures/error_placeholder.png", false, false, NULL);
	}

	for (size_t i = 0; i < backend->numTextures; i++)
	{
		if (!backend->allTextures[i]) continue;

		if (backend->allTextures[i]->filename == filename)
		{
			if (out_IsNew)
				*out_IsNew = false;

			return backend->allTextures[i];
		}
	}

	if (out_IsNew)
		*out_IsNew = true;

	if (backend->numTextures < MAX_TEXTURES)
	{
		Texture* newTex = NEW(Texture);
		check(newTex, "Failed to allocate memory for LoadTexture()!");
		backend->createTextureImage(filename, isNormal, freeFilename, newTex);
		newTex->textureIndex = backend->numTextures;
		backend->allTextures[backend->numTextures] = newTex;

		return backend->allTextures[backend->numTextures++];
	}

	std::cout << "No more room to add textures!";
	return backend->allTextures[0];
}

bool VulkanEngine::OnScreen(float3 worldPoint)
{
	float4 screenPos = backend->GetActiveCamera()->matrix * float4(worldPoint, 1);
	screenPos.x /= screenPos.w;
	screenPos.y /= screenPos.w;
	return screenPos.x > -1 && screenPos.x < 1 && screenPos.y > -1 && screenPos.y < 1;
}

static float3 ProjectPosition(float4x4& matrix, float4& pos)
{
	float4 screenPos = matrix * pos;
	return float3(screenPos.x / screenPos.z, screenPos.y / screenPos.z, -screenPos.z);
}

Mexel* VulkanEngine::LoadMexelFromFile(char* filename)
{
	if (!FileExists(filename))
	{
		std::cout << "Mesh file: " << filename << " does not exist!" << "\n";
		free(filename);
		return NULL;
	}

	for (int i = 0; i < backend->allMexels.size(); i++)
	{
		if (backend->allMexels[i]->Filename == filename)
			return backend->allMexels[i];
	}

	auto mesh = NEW(Mexel);
	check(mesh, "Failed to allocate mesh");

	mesh->Filename = filename;

	auto data = readFile(filename);

	Vertex* vertices;
	void* indices;

	char* ptr = data.data();

	// 1 = 32-bit indices, 0 = 16-bit indices
	BYTE meshType = *ptr;
	ptr++;

	unsigned int numVerts;

	if (meshType)
	{
		numVerts = IncReadAs(ptr, unsigned int);
	}
	else
	{
		numVerts = IncReadAs(ptr, uint16_t);
	}

	vertices = (Vertex*)ptr;
	ptr += numVerts * sizeof(Vertex);

	float3 boundingBoxMin = vertices[0].pos;
	float3 boundingBoxMax = vertices[0].pos;

	for (uint32_t i = 1; i < numVerts; i++)
	{
		boundingBoxMin = glm::min(boundingBoxMin, vertices[i].pos);
		boundingBoxMax = glm::max(boundingBoxMax, vertices[i].pos);
	}

	float3 boundingBoxCentre = ((boundingBoxMax - boundingBoxMin) / float3(2)) + boundingBoxMin;

	unsigned int numIndices;
	size_t indexSize;

	if (meshType)
	{
		numIndices = IncReadAs(ptr, unsigned int);
		indexSize = sizeof(unsigned int);
	}
	else
	{
		numIndices = IncReadAs(ptr, uint16_t);
		indexSize = sizeof(uint16_t);
	}

	indices = ptr;
	ptr += numIndices * indexSize;

	check(numVerts, "No vertices read!");
	check(numIndices, "No indices read!");

	backend->allMexels.push_back(mesh);
	*backend->allMexels.back() = backend->createVertexBuffer(vertices, numVerts, indices, numIndices, indexSize);

	backend->allMexels.back()->boundingBoxMin = boundingBoxMin;
	backend->allMexels.back()->boundingBoxMax = boundingBoxMax;
	backend->allMexels.back()->boundingBoxCentre = boundingBoxCentre;
	ptr += sizeof(float) * 3;
	backend->stats.triangle_count += numIndices / 3;
	return backend->allMexels.back();
}

static void PrintFloat2(const char* prefix, float2& vec, const char* suffix)
{
	std::cout << prefix << "[" << vec.x << ", " << vec.y << "]" << suffix;
}

static void PrintFloat3(const char* prefix, float3& vec, const char* suffix)
{
	printf("%s[%f, %f, %f]%s", prefix, vec.x, vec.y, vec.z, suffix);
}

Mesh* VulkanEngine::LoadMeshFromGLTF(const char* filename)
{
	Mesh* mesh = NULL;
	Mexel* mexel;

	cgltf_options options = {};
	cgltf_data* data = NULL;
	std::vector<Vertex> vertices = {};

	if (cgltf_parse_file(&options, filename, &data) == cgltf_result_success)
	{
		mesh = NEW(Mesh);
		check(mesh, "Failed to allocate mesh for LoadMeshFromGLTF!");
		ZEROMEM(mesh, sizeof(Mesh));

		mexel = NEW(Mexel);
		check(mexel, "Failed to allocate mexel for LoadMeshFromGLTF!");
		ZEROMEM(mexel, sizeof(Mexel));

		backend->allMexels.push_back(mexel);
		mesh->mexels = { mexel };

		if (data->meshes_count)
		{
			mexel->Filename = filename;
			cgltf_mesh* cMesh = &data->meshes[0];
			mexel->IndexBufferLength = 0;
			mexel->startingIndex = backend->AddIndexBuffer16(NULL, 0);
			for (uint32_t i = 0; i < cMesh->primitives_count; i++)
			{
				cgltf_primitive* prim = &cMesh->primitives[i];

				if (prim->type != cgltf_primitive_type_triangles)
					std::cout << "The mesh must consist of triangles";

				mexel->IndexBufferLength += prim->indices->count;
				switch (prim->indices->component_type)
				{
					case cgltf_component_type_r_16u:
						backend->AddIndexBuffer16((uint16_t*)((size_t)data->bin + cMesh->primitives[i].indices->buffer_view->offset), cMesh->primitives[i].indices->count);
						break;
					case cgltf_component_type_r_32u:
						backend->AddIndexBuffer32((uint32_t*)((size_t)data->bin + cMesh->primitives[i].indices->buffer_view->offset), cMesh->primitives[i].indices->count);
						break;
					default:
						std::cout << "Invalid index type\n";
						break;
				}

				cgltf_attribute* positions = NULL;
				cgltf_attribute* uvs = NULL;
				cgltf_attribute* lightmapUVs = NULL;
				cgltf_attribute* normals = NULL;
				cgltf_attribute* tangents = NULL;
				for (uint32_t j = 0; j < prim->attributes_count; j++)
				{
					switch (prim->attributes[j].type)
					{
						case cgltf_attribute_type_texcoord:
							if (uvs)
								lightmapUVs = &prim->attributes[j];
							else
								uvs = &prim->attributes[j];
							break;
						case cgltf_attribute_type_position:
							positions = &prim->attributes[j];
							break;
						case cgltf_attribute_type_normal:
							normals = &prim->attributes[j];
							break;
						case cgltf_attribute_type_tangent:
							tangents = &prim->attributes[j];
							break;
					}
				}

				if (!positions)
				{
					std::cout << "Mesh has no positions!\n";
					goto Exit;
				}

				if (!normals)
				{
					std::cout << "Mesh has no normals!\n";
					goto Exit;
				}

				if (!tangents)
				{
					std::cout << "Mesh has no tangents!\n";
					goto Exit;
				}

				if (!uvs)
				{
					std::cout << "Mesh has no UVs!\n";
					goto Exit;
				}

				if (!lightmapUVs)
				{
					std::cout << "Mesh has no lightmap UVs!";
					goto Exit;
				}

				std::cout << positions->data->count << ", " << normals->data->count << ", " << tangents->data->count << ", " << uvs->data->count << ", " << lightmapUVs->data->count << "\n";

				float3* posPtr = (float3*)((size_t)data->bin + positions->data->buffer_view->offset);
				float3* nrmPtr = (float3*)((size_t)data->bin + normals->data->buffer_view->offset);
				float4* tangentPtr = (float4*)((size_t)data->bin + tangents->data->buffer_view->offset);
				float2* uv1Ptr = (float2*)((size_t)data->bin + uvs->data->buffer_view->offset);
				float2* uv2Ptr = (float2*)((size_t)data->bin + lightmapUVs->data->buffer_view->offset);

				Vertex v;
				uint16_t* indexPtr = (uint16_t*)((size_t)data->bin + prim->indices->buffer_view->offset);
				for (cgltf_size i = 0; i < prim->indices->count; i++)
				{
					printf("%u: ", (uint16_t)*indexPtr);
					PrintFloat3("Vertex: ", posPtr[*indexPtr], " ");
					PrintFloat3("", nrmPtr[*indexPtr], " ");
					PrintFloat3("", (float3&)tangentPtr[*indexPtr], " ");
					PrintFloat2("", uv1Ptr[*indexPtr], " ");
					PrintFloat2("", uv2Ptr[*indexPtr], "\n");
					indexPtr += 2;
				}

				assert(false);

				for (uint32_t j = 0; j < positions->data->count; j++)
				{
					PrintFloat3("Vertex: ", *posPtr, " ");
					PrintFloat3("", *nrmPtr, " ");
					PrintFloat3("", (float3&)tangentPtr, " ");
					PrintFloat2("", *uv1Ptr, " ");
					PrintFloat2("", *uv2Ptr, "\n");

					v.pos.x = IncReadAs(posPtr, float);
					v.pos.y = IncReadAs(posPtr, float);
					v.pos.z = IncReadAs(posPtr, float);
					v.nrm.x = IncReadAs(nrmPtr, float);
					v.nrm.y = IncReadAs(nrmPtr, float);
					v.nrm.z = IncReadAs(nrmPtr, float);
					v.tangent.x = IncReadAs(tangentPtr, float);
					v.tangent.y = IncReadAs(tangentPtr, float);
					v.tangent.z = IncReadAs(tangentPtr, float);
					v.uv.x = IncReadAs(uv1Ptr, float);
					v.uv.y = IncReadAs(uv1Ptr, float);
					v.uv.z = IncReadAs(uv2Ptr, float);
					v.uv.w = IncReadAs(uv2Ptr, float);

					vertices.push_back(v);

					//posPtr += positions->data->stride;
					//nrmPtr += normals->data->stride;
					//tangentPtr += tangents->data->stride;
					//uv1Ptr += uvs->data->stride;
					//uv2Ptr += lightmapUVs->data->stride;
				}
			}

			mexel->startingVertex = backend->AddVertexBuffer(vertices.data(), vertices.size());
		}
		else
			std::cout << "This GLTF file has no mesh data!\n";

Exit:
		cgltf_free(data);
	}

	return mesh;
}

bool VulkanEngine::hasStencilComponent(VkFormat format)
{
	return format == VK_FORMAT_D32_SFLOAT_S8_UINT || format == VK_FORMAT_D24_UNORM_S8_UINT;
}

void VulkanEngine::InterpretConsoleCommand()
{
	ZEROMEM(consoleReadBuffer, 64);

	char* ptr = consoleBuffer;
	char* outPtr = consoleReadBuffer;

	while (!isspace(*ptr))
		*outPtr++ = *ptr++;

	while (isspace(*ptr)) ptr++;

	if (!strcmp(consoleReadBuffer, "map"))
	{
		if (FileExists(ptr))
			LoadLevel_FromFile(ptr);
		else
			consoleOutput.push_back("Map does not exist!");

		return;
	}

	for (uint32_t i = 0; i < NUMCONSOLEVARS; i++)
	{
		if (!strcmp(consoleReadBuffer, consoleVars[i].name))
		{
			long long aslong = atoll(ptr);

			switch (consoleVars[i].type)
			{
			case CCVT_BOOL:
				*(bool*)consoleVars[i].ptr = strcmp(ptr, "false");
				break;
			case CCVT_CHAR:
				*(char*)consoleVars[i].ptr = *ptr;
				break;
			case CCVT_UCHAR:
				*(unsigned char*)consoleVars[i].ptr = aslong;
				break;
			case CCVT_SHORT:
				*(short*)consoleVars[i].ptr = aslong;
				break;
			case CCVT_USHORT:
				*(unsigned short*)consoleVars[i].ptr = aslong;
				break;
			case CCVT_INT:
				*(int*)consoleVars[i].ptr = aslong;
				break;
			case CCVT_UINT:
				*(unsigned int*)consoleVars[i].ptr = aslong;
				break;
			case CCVT_LONG:
				*(long long*)consoleVars[i].ptr = aslong;
				break;
			case CCVT_ULONG:
				*(unsigned long long*)consoleVars[i].ptr = aslong;
				break;
			case CCVT_FLOAT:
				*(float*)consoleVars[i].ptr = atof(ptr);
				break;
			case CCVT_DOUBLE:
				*(double*)consoleVars[i].ptr = atof(ptr);
				break;
			}
		}
	}
}

#define ReadSnip(ptr, buffer, length) (ZEROMEM(buffer, length), ReadSnippet(ptr, buffer))

void LoadLevelFromFile(const char* filename)
{
	g_App->LoadLevel_FromFile(filename);
}

Texture*& LoadTexture(const char* filename, bool isNormal, bool freeFilename, bool* out_isNew)
{
	return g_App->LoadTexture(filename, isNormal, freeFilename, out_isNew);
}

void RecordStaticCommandBuffer()
{
	g_App->backend->RecordPostProcessCommandBuffers();
}

bool LevelLoaded()
{
	return g_App->levelLoaded;
}

Mexel* LoadMexelFromFile(char* filename)
{
	return g_App->LoadMexelFromFile(filename);
}

MeshObject** GetObjectList(size_t& out_numObjects)
{
	out_numObjects = g_App->backend->allObjectsLen;
	return g_App->backend->allObjects;
}


void AddMovingObject(MeshObject* mo, float3 moveTo, float moveSpeed, const char* callback)
{
	movingObjects[numMovingObjects++] = { mo, moveTo, moveSpeed, callback };
}

void RemoveMovingObject(uint32_t index)
{
	numMovingObjects--;

	for (uint32_t i = index; i < numMovingObjects; i++)
	{
		movingObjects[i] = movingObjects[i + 1];
	}
}

bool RayObjects(float3 rayOrigin, float3 rayDir, int id, MeshObject** outObject, float* outDst)
{
	return g_App->RayObjects(rayOrigin, rayDir, id, outObject, outDst);
}

MeshObject::MeshObject(float3 position, float3 rotation, float3 scale, Mesh* mesh, Texture* shadowMap, float texScale, bool isStatic, bool castShadow, BYTE id, const char* scriptFilename)
{
	this->mesh = mesh;

	this->position = position;
	this->rotation = rotation;
	this->scale = scale;

	this->shadowMap = shadowMap;
	this->isStatic = isStatic;
	this->castShadow = castShadow;
	this->id = id;
}

void MeshObject::UpdateMatrix(float4x4* overrideMatrix) const
{
	if (isStatic)
	{
		PrintF("Cannot update matrix on a static object!");
		return;
	}

	float4x4 worldMatrix;
	if (overrideMatrix)
		worldMatrix = *overrideMatrix;
	else
		worldMatrix = WorldMatrix(position, rotation, scale);

	size_t len = meshGroups.size();
	for (size_t i = 0; i < len; i++)
	{
		float4x4* data = (float4x4*)meshGroups[i]->matrixMem->Map(matrixIndices[i] * sizeof(float4x4), sizeof(float4x4));
		*data = worldMatrix;
		meshGroups[i]->matrixMem->UnMap();
	}
}

VulkanMemory::VulkanMemory(VulkanBackend* backend, size_t size, VkBufferUsageFlags usage, const char* origin, bool isStatic, void* data)
{
	this->origin = origin;
	this->size = size;
	this->logicalDevice = backend->logicalDevice;

	if (isStatic)
	{
		backend->CreateStaticBuffer(data, size, usage, buffer, memory);
		return;
	}

	VkBufferCreateInfo bufferInfo{};
	bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
	bufferInfo.size = size;
	bufferInfo.usage = usage;
	bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

	if (vkCreateBuffer(backend->logicalDevice, &bufferInfo, nullptr, &buffer) != VK_SUCCESS)
		throw std::runtime_error("failed to create buffer!");

	VkMemoryRequirements memRequirements;
	vkGetBufferMemoryRequirements(backend->logicalDevice, buffer, &memRequirements);
	VkMemoryAllocateInfo allocInfo{};
	allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	allocInfo.allocationSize = memRequirements.size;
	allocInfo.memoryTypeIndex = backend->findMemoryType(backend->physicalDevice, memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);

	VkResult vr;
	if ((vr = vkAllocateMemory(backend->logicalDevice, &allocInfo, nullptr, &memory)) != VK_SUCCESS)
	{
		std::cout << String_VkResult(vr) << "\n";
		throw std::runtime_error("Failed to allocate buffer memory!");
	}

	vkBindBufferMemory(backend->logicalDevice, buffer, memory, 0);

	destroyed = false;
	g_App->allBuffers.push_back(this);
}

SunLight::SunLight(float3 dir, uint32_t width, uint32_t height, VulkanBackend* backend)
{
	this->dir = dir;
	this->offset = dir * -2500.f;
	this->orthoParams = float4(2.0f, 4.0f, 0.0f, 0.0f);

	commandBuffers.resize(backend->MAX_FRAMES_IN_FLIGHT);
	VkCommandBufferAllocateInfo cmdInfo{};
	cmdInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
	cmdInfo.pNext = VK_NULL_HANDLE;
	cmdInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
	cmdInfo.commandBufferCount = 1;
	for (uint32_t j = 0; j < NUMCASCADES; j++)
	{
		cmdInfo.commandPool = backend->sunThreadCommandPools[j];
		for (uint32_t i = 0; i < backend->MAX_FRAMES_IN_FLIGHT; i++)
			vkAllocateCommandBuffers(backend->logicalDevice, &cmdInfo, &commandBuffers[i][j]);
	}

	for (uint32_t i = 0; i < NUMCASCADES; i++)
	{
		FullCreateImage(VK_IMAGE_TYPE_2D, VK_IMAGE_VIEW_TYPE_2D, backend->findDepthFormat(), width, height, 1, 1, VK_SAMPLE_COUNT_1_BIT, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_ASPECT_DEPTH_BIT, VK_FILTER_LINEAR, VK_FILTER_LINEAR, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, this->renderTargets[i].Image, this->renderTargets[i].Memory, this->renderTargets[i].View, this->renderTargets[i].Sampler, true);
		this->renderTargets[i].Width = width;
		this->renderTargets[i].Height = height;
	}

	VkFramebufferCreateInfo framebufferInfo{};
	framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
	// We first need to specify with which renderPass the framebuffer needs to be compatible.
	// You can only use a framebuffer with the render passes that it is compatible with, which roughly means that they use the same number and type of attachments.
	framebufferInfo.renderPass = backend->lightRenderPass;
	// The attachmentCount and pAttachments parameters specify the VkImageView objects that should be bound to the respective attachment descriptions in the render pass pAttachment array.
	framebufferInfo.attachmentCount = 1;

	// The width and height parameters are self-explanatory and layers refers to the number of layers in image arrays.
	framebufferInfo.width = width;
	framebufferInfo.height = height;

	// Our swap chain images are single images, so the number of layers is 1.
	framebufferInfo.layers = 1;

	for (uint32_t i = 0; i < NUMCASCADES; i++)
	{
		framebufferInfo.pAttachments = &renderTargets[i].View;
		vkCreateFramebuffer(backend->logicalDevice , &framebufferInfo, nullptr, &this->frameBuffers[i]);
	}

	this->viewProjBuffer.resize(backend->MAX_FRAMES_IN_FLIGHT);

	for (size_t i = 0; i < backend->MAX_FRAMES_IN_FLIGHT; i++)
		this->viewProjBuffer[i] = new VulkanMemory(backend, (sizeof(float4x4) * NUMCASCADES) + sizeof(float4), VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, "SunLight", false, NULL);

	VkDescriptorSetAllocateInfo info{};
	info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
	info.pNext = nullptr;
	info.descriptorPool = backend->descriptorPool;
	info.descriptorSetCount = NUMCASCADES;

	VkDescriptorSetLayout setLayouts[NUMCASCADES];
	for (uint32_t i = 0; i < NUMCASCADES; i++)
		setLayouts[i] = *g_App->backend->GetDescriptorSetLayout(1, 0, 0);

	this->descriptorSetVS.resize(backend->MAX_FRAMES_IN_FLIGHT);
	this->descriptorSetPS.resize(backend->MAX_FRAMES_IN_FLIGHT);

	info.pSetLayouts = setLayouts;
	for (size_t i = 0; i < backend->MAX_FRAMES_IN_FLIGHT; i++)
		vkAllocateDescriptorSets(backend->logicalDevice, &info, this->descriptorSetVS[i].data());

	setLayouts[0] = *g_App->backend->GetDescriptorSetLayout(0, 1, NUMCASCADES);
	info.descriptorSetCount = 1;
	for (size_t i = 0; i < backend->MAX_FRAMES_IN_FLIGHT; i++)
		vkAllocateDescriptorSets(backend->logicalDevice, &info, &this->descriptorSetPS[i]);

	VkDescriptorBufferInfo bufferInfos[NUMCASCADES];
	size_t offset = 0;
	VkWriteDescriptorSet writes[NUMCASCADES + 1];
	for (size_t j = 0; j < backend->MAX_FRAMES_IN_FLIGHT; j++)
	{
		offset = 0;
		for (uint32_t i = 0; i < NUMCASCADES; i++)
		{
			bufferInfos[i].buffer = *this->viewProjBuffer[j];
			bufferInfos[i].offset = offset;
			bufferInfos[i].range = sizeof(float4x4);
			offset += sizeof(float4x4);

			writes[i].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
			writes[i].pNext = nullptr;
			writes[i].dstSet = this->descriptorSetVS[j][i];
			writes[i].dstBinding = 0;
			writes[i].dstArrayElement = 0;
			writes[i].descriptorCount = 1;
			writes[i].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
			writes[i].pBufferInfo = &bufferInfos[i];
		}

		vkUpdateDescriptorSets(backend->logicalDevice, NUMCASCADES, writes, 0, nullptr);
	}

	VkDescriptorImageInfo imageInfos[NUMCASCADES];

	for (size_t j = 0; j < backend->MAX_FRAMES_IN_FLIGHT; j++)
	{
		writes[0].dstSet = this->descriptorSetPS[j];
		bufferInfos[0].buffer = *this->viewProjBuffer[j];
		bufferInfos[0].range = sizeof(float4x4) * NUMCASCADES + sizeof(float4);

		for (uint32_t i = 1; i < (NUMCASCADES + 1); i++)
		{
			writes[i].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
			writes[i].dstSet = this->descriptorSetPS[j];
			writes[i].dstBinding = i;
			writes[i].dstArrayElement = 0;
			writes[i].descriptorCount = 1;
			writes[i].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
			writes[i].pBufferInfo = VK_NULL_HANDLE;
			writes[i].pNext = VK_NULL_HANDLE;

			imageInfos[i - 1].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
			imageInfos[i - 1].imageView = this->renderTargets[i - 1].View;
			imageInfos[i - 1].sampler = this->renderTargets[i - 1].Sampler;
			writes[i].pImageInfo = &imageInfos[i - 1];
		}

		vkUpdateDescriptorSets(backend->logicalDevice, NUMCASCADES + 1, writes, 0, nullptr);
	}

	cascadeDistances[0] = 8.f;
	cascadeDistances[1] = 25.f;
	cascadeDistances[2] = 50.f;
	cascadeDistances[3] = 200.f;

	UpdateProjection();
}

SunLight::~SunLight()
{
	for (uint32_t i = 0; i < g_App->backend->MAX_FRAMES_IN_FLIGHT; i++)
		delete viewProjBuffer[i];

	for (uint32_t i = 0; i < NUMCASCADES; i++)
	{
		vkDestroyFramebuffer(g_App->backend->logicalDevice, frameBuffers[i], VK_NULL_HANDLE);
		g_App->backend->DestroyTexture(&renderTargets[i]);
	}
}

SpotLight::SpotLight(float3 position, float3 dir, float fov, float attenuation, uint32_t width, uint32_t height, VulkanBackend* backend)
{
	this->position = float4(position, attenuation);
	this->dir = float4(dir, fov);

	device = backend->logicalDevice;

	FullCreateImage(VK_IMAGE_TYPE_2D, VK_IMAGE_VIEW_TYPE_2D, backend->findDepthFormat(), width, height, 1, 1, VK_SAMPLE_COUNT_1_BIT, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_ASPECT_DEPTH_BIT, VK_FILTER_LINEAR, VK_FILTER_LINEAR, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, this->renderTarget.Image, this->renderTarget.Memory, this->renderTarget.View, this->renderTarget.Sampler, true);
	this->renderTarget.Width = width;
	this->renderTarget.Height = height;

	commandBuffers.resize(backend->MAX_FRAMES_IN_FLIGHT);

	auto queueFamily = backend->findQueueFamilies(backend->physicalDevice);
	VkCommandPoolCreateInfo poolInfo = MakeCommandPoolCreateInfo(queueFamily.graphicsFamily, VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT);
	vkCreateCommandPool(backend->logicalDevice, &poolInfo, VK_NULL_HANDLE, &commandPool);

	VkCommandBufferAllocateInfo commandBufferInfo{};
	commandBufferInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
	commandBufferInfo.commandBufferCount = backend->MAX_FRAMES_IN_FLIGHT;
	commandBufferInfo.commandPool = commandPool;
	commandBufferInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
	commandBufferInfo.pNext = VK_NULL_HANDLE;
	vkAllocateCommandBuffers(backend->logicalDevice, &commandBufferInfo, commandBuffers.data());

	VkFramebufferCreateInfo framebufferInfo{};
	framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
	// We first need to specify with which renderPass the framebuffer needs to be compatible.
	// You can only use a framebuffer with the render passes that it is compatible with, which roughly means that they use the same number and type of attachments.
	framebufferInfo.renderPass = backend->lightRenderPass;
	// The attachmentCount and pAttachments parameters specify the VkImageView objects that should be bound to the respective attachment descriptions in the render pass pAttachment array.
	framebufferInfo.attachmentCount = 1;

	// The width and height parameters are self-explanatory and layers refers to the number of layers in image arrays.
	framebufferInfo.width = width;
	framebufferInfo.height = height;

	// Our swap chain images are single images, so the number of layers is 1.
	framebufferInfo.layers = 1;

	framebufferInfo.pAttachments = &renderTarget.View;
	vkCreateFramebuffer(backend->logicalDevice, &framebufferInfo, nullptr, &this->frameBuffer);

	this->viewProjBuffer.resize(backend->MAX_FRAMES_IN_FLIGHT);
	this->descriptorSetVS.resize(backend->MAX_FRAMES_IN_FLIGHT);
	this->descriptorSetPS.resize(backend->MAX_FRAMES_IN_FLIGHT);

	for (size_t i = 0; i < backend->MAX_FRAMES_IN_FLIGHT; i++)
		this->viewProjBuffer[i] = new VulkanMemory(backend, sizeof(float4x4) + sizeof(float4) * 2, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, "SpotLight", false, NULL);

	VkDescriptorSetAllocateInfo info{};
	info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
	info.pNext = nullptr;
	info.descriptorPool = backend->descriptorPool;
	info.descriptorSetCount = 1;

	info.pSetLayouts = backend->GetDescriptorSetLayout(1, 0, 0);
	for (size_t i = 0; i < backend->MAX_FRAMES_IN_FLIGHT; i++)
		vkAllocateDescriptorSets(backend->logicalDevice, &info, &this->descriptorSetVS[i]);

	info.pSetLayouts = backend->GetDescriptorSetLayout(0, 1, 1);
	for (size_t i = 0; i < backend->MAX_FRAMES_IN_FLIGHT; i++)
		vkAllocateDescriptorSets(backend->logicalDevice, &info, &this->descriptorSetPS[i]);

	VkDescriptorBufferInfo bufferInfo{};
	size_t offset = 0;
	VkWriteDescriptorSet writes[2];

	bufferInfo.offset = 0;
	bufferInfo.range = sizeof(float4x4);

	writes[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
	writes[0].pNext = nullptr;
	writes[0].dstBinding = 0;
	writes[0].dstArrayElement = 0;
	writes[0].descriptorCount = 1;
	writes[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
	writes[0].pBufferInfo = &bufferInfo;

	for (size_t i = 0; i < backend->MAX_FRAMES_IN_FLIGHT; i++)
	{
		bufferInfo.buffer = *this->viewProjBuffer[i];
		writes[0].dstSet = this->descriptorSetVS[i];
		vkUpdateDescriptorSets(backend->logicalDevice, 1, writes, 0, nullptr);
	}

	bufferInfo.range += sizeof(float4) * 2;

	VkDescriptorImageInfo imageInfo{};

	writes[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
	writes[1].dstBinding = 1;
	writes[1].dstArrayElement = 0;
	writes[1].descriptorCount = 1;
	writes[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
	writes[1].pBufferInfo = VK_NULL_HANDLE;
	writes[1].pNext = VK_NULL_HANDLE;

	imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
	imageInfo.imageView = this->renderTarget.View;
	imageInfo.sampler = this->renderTarget.Sampler;
	writes[1].pImageInfo = &imageInfo;

	for (size_t i = 0; i < backend->MAX_FRAMES_IN_FLIGHT; i++)
	{
		writes[0].dstSet = this->descriptorSetPS[i];
		bufferInfo.buffer = *this->viewProjBuffer[i];
		writes[1].dstSet = this->descriptorSetPS[i];
		vkUpdateDescriptorSets(backend->logicalDevice, 2, writes, 0, nullptr);

		this->UpdateMatrix(NULL, i);
	}

	thread.backend = backend;
	thread.done = false;
	thread.go = false;
	thread.light = this;

	thread.passInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
	thread.passInfo.renderPass = backend->lightRenderPass;
	thread.passInfo.framebuffer = frameBuffer;
	thread.passInfo.clearValueCount = 1;
	thread.passInfo.pClearValues = &backend->clearValues[1];
	thread.passInfo.renderArea = { 0, 0, SHADOWMAPSIZE, SHADOWMAPSIZE };
	thread.passInfo.pNext = VK_NULL_HANDLE;

	thread.thread = new Thread((zThreadFunc)SpotLightThreadProc, &thread);
}

ComputeShader::ComputeShader(VulkanBackend* backend, const char* filename, size_t numUniformBuffers, size_t numStorageBuffers, size_t numStorageImages, size_t numSamplers)
{
	this->filename = filename;
	// Includes the uniform buffer that the compute shader has built-in
	this->numUniformBuffers = numUniformBuffers + 1;
	this->numStorageBuffers = numStorageBuffers;
	this->numStorageImages = numStorageImages;
	this->numSamplers = numSamplers;

	uniformBuffers.resize(backend->MAX_FRAMES_IN_FLIGHT);
	descriptorSets.resize(backend->MAX_FRAMES_IN_FLIGHT);

	setLayout = *backend->GetComputeDescriptorSet(numUniformBuffers, numStorageBuffers, numStorageImages, numSamplers);

	for (uint32_t i = 0; i < backend->MAX_FRAMES_IN_FLIGHT; i++)
		backend->AllocateDescriptorSets(1, &setLayout, &descriptorSets[i]);

	lastModified = FileDate(filename);

	ConvertFilename();
	GetInfoFromComp();

	device = backend->logicalDevice;
	auto shaderCode = readFile(spvFilename);
	auto shaderModule = backend->createShaderModule(shaderCode);

	VkPipelineLayoutCreateInfo layoutInfo{};
	layoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
	layoutInfo.pNext = VK_NULL_HANDLE;
	layoutInfo.flags = VK_FLAGS_NONE;
	layoutInfo.pSetLayouts = &setLayout;
	layoutInfo.setLayoutCount = 1;
	layoutInfo.pPushConstantRanges = VK_NULL_HANDLE;
	layoutInfo.pushConstantRangeCount = 0;
	vkCreatePipelineLayout(device, &layoutInfo, VK_NULL_HANDLE, &pipelineLayout);

	VkComputePipelineCreateInfo createInfo{};
	createInfo.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
	createInfo.pNext = VK_NULL_HANDLE;
	createInfo.layout = pipelineLayout;
	createInfo.basePipelineHandle = VK_NULL_HANDLE;
	createInfo.basePipelineIndex = 0;
	createInfo.flags = VK_FLAGS_NONE;

	createInfo.stage.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	createInfo.stage.pName = "main";
	createInfo.stage.module = shaderModule;
	createInfo.stage.stage = VK_SHADER_STAGE_COMPUTE_BIT;
	createInfo.stage.pNext = VK_NULL_HANDLE;
	createInfo.stage.flags = VK_FLAGS_NONE;

	vkCreateComputePipelines(device, VK_NULL_HANDLE, 1, &createInfo, VK_NULL_HANDLE, &pipeline);
}


int Lua_TextureGC(lua_State* L)
{
	lua_getfield(L, 1, "texture");
	Texture* tex = (Texture*)lua_touserdata(L, -1);
	lua_pop(L, 1);

	if (tex->freeFilename)
		free((void*)tex->filename);

	vkDestroyImage(g_App->backend->logicalDevice, tex->Image, nullptr);
	if (tex->View)
		vkDestroyImageView(g_App->backend->logicalDevice, tex->View, nullptr);

	vkFreeMemory(g_App->backend->logicalDevice, tex->Memory, nullptr);

	if (tex->Sampler)
		vkDestroySampler(g_App->backend->logicalDevice, tex->Sampler, nullptr);

	free(tex);

	return 0;
}

static int LuaFN_RenderPassGC(lua_State* L)
{
	RenderPass* pass = Lua_GetRenderPass(L, 1);
	vkDestroyRenderPass(g_App->backend->logicalDevice, pass->renderPass, VK_NULL_HANDLE);
	free(pass);
	return 0;
}

static void LuaFN_PushRenderPass_NoGC(lua_State* L, RenderPass* pass)
{
	lua_createtable(L, 0, 1);
	lua_pushlightuserdata(L, pass);
	lua_setfield(L, -2, "data");
}

static void LuaFN_PushRenderPass(lua_State* L, RenderPass* pass)
{
	LuaFN_PushRenderPass_NoGC(L, pass);

	lua_createtable(L, 0, 1);
	lua_pushcclosure(L, LuaFN_RenderPassGC, 0);
	lua_setfield(L, -2, "__gc");

	lua_setmetatable(L, -2);
}


int LuaFN_CreateRenderPass(lua_State* L)
{
	auto pass = NEW(RenderPass);
	ZEROMEM(pass, sizeof(RenderPass));

	std::vector<VkAttachmentDescription> attachmentDesc;

	lua_len(L, 2);
	int numAttachments = lua_tointeger(L, -1);
	lua_pop(L, 1);

	for (int i = 0; i < numAttachments; i++)
	{
		lua_geti(L, 2, i + 1);

		attachmentDesc.push_back({});

		attachmentDesc.back().initialLayout = (VkImageLayout)IntFromTable(L, -1, 1, "initialLayout");
		attachmentDesc.back().finalLayout = (VkImageLayout)IntFromTable(L, -1, 2, "finalLayout");
		pass->layouts.push_back({ attachmentDesc.back().initialLayout, attachmentDesc.back().finalLayout });

		attachmentDesc.back().format = (VkFormat)IntFromTable(L, -1, 3, "format");
		attachmentDesc.back().loadOp = (VkAttachmentLoadOp)IntFromTable(L, -1, 4, "loadOp");
		attachmentDesc.back().storeOp = (VkAttachmentStoreOp)IntFromTable(L, -1, 5, "storeOp");
		attachmentDesc.back().samples = (VkSampleCountFlagBits)IntFromTable(L, -1, 6, "samples");
		attachmentDesc.back().stencilLoadOp = attachmentDesc.back().loadOp;
		attachmentDesc.back().stencilStoreOp = attachmentDesc.back().storeOp;

		lua_pop(L, 1);
	}

	VkSubpassDescription subPass{};

	std::vector<VkAttachmentReference> depthDescription;

	std::vector<VkAttachmentReference> colourAttachments;
	lua_len(L, 3);
	int numColourAttachments = lua_tointeger(L, -1);
	lua_pop(L, 1);

	for (int i = 0; i < numColourAttachments; i++)
	{
		lua_geti(L, 3, i + 1);
		colourAttachments.push_back({});
		colourAttachments.back().attachment = IntFromTable(L, -1, 1, "attachment");
		colourAttachments.back().layout = (VkImageLayout)IntFromTable(L, -1, 2, "layout");
		lua_pop(L, 1);
	}

	if (lua_type(L, 4) == LUA_TTABLE)
	{
		depthDescription.push_back({});
		depthDescription.back().attachment = IntFromTable(L, 4, 1, "depth attachment");
		depthDescription.back().layout = (VkImageLayout)IntFromTable(L, 4, 2, "depth layout");
	}

	std::vector<VkAttachmentReference> resolveAttachments;
	if (lua_type(L, 5) == LUA_TTABLE)
	{
		lua_len(L, 5);
		resolveAttachments.resize(lua_tointeger(L, -1));
		lua_pop(L, 1);

		for (uint32_t i = 0; i < resolveAttachments.size(); i++)
		{
			lua_geti(L, 5, i + 1);
			resolveAttachments[i].attachment = IntFromTable(L, -1, 1, "resolve attachment");
			resolveAttachments[i].layout = (VkImageLayout)IntFromTable(L, -1, 2, "resolve layout");
			lua_pop(L, 1);
		}
	}

	subPass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
	subPass.colorAttachmentCount = colourAttachments.size();
	subPass.pColorAttachments = colourAttachments.data();
	subPass.pResolveAttachments = resolveAttachments.data();

	subPass.pDepthStencilAttachment = depthDescription.size() ? depthDescription.data() : nullptr;

	VkRenderPassCreateInfo createInfo{};
	createInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
	createInfo.attachmentCount = numAttachments;
	createInfo.pAttachments = attachmentDesc.data();

	createInfo.subpassCount = 1;
	createInfo.pSubpasses = &subPass;

	std::vector<VkSubpassDependency> depends;
	lua_len(L, 7);
	int numDependencies = lua_tointeger(L, -1);
	lua_pop(L, 1);

	for (int i = 0; i < numDependencies; i++)
	{
		lua_geti(L, 7, i + 1);
		int tableDex = lua_gettop(L);
		depends.push_back({});
		depends.back().srcSubpass = IntFromTable(L, tableDex, 1, "srcSubpass");
		depends.back().dstSubpass = IntFromTable(L, tableDex, 2, "dstSubpass");
		depends.back().srcStageMask = IntFromTable(L, tableDex, 3, "srcStageMask");
		depends.back().dstStageMask = IntFromTable(L, tableDex, 4, "dstStageMask");
		depends.back().srcAccessMask = IntFromTable(L, tableDex, 5, "srcAccessMask");
		depends.back().dstAccessMask = IntFromTable(L, tableDex, 6, "dstAccessMask");
		depends.back().dependencyFlags = IntFromTable(L, tableDex, 7, "dependencyFlags");

		lua_pop(L, 1);
	}

	createInfo.dependencyCount = numDependencies;
	createInfo.pDependencies = numDependencies ? depends.data() : nullptr;

	createInfo.pNext = nullptr;

	vkCreateRenderPass(g_App->backend->logicalDevice, &createInfo, NULL, &pass->renderPass);

	LuaFN_PushRenderPass(L, pass);

	return 1;
}

static int LuaFN_FrameBufferGC(lua_State* L)
{
	lua_getfield(L, 1, "buffer");
		VkFramebuffer frameBuffer = (VkFramebuffer)lua_touserdata(L, -1);
	lua_pop(L, 1);
	vkDestroyFramebuffer(g_App->backend->logicalDevice, frameBuffer, VK_NULL_HANDLE);
	return 0;
}

int LuaFN_CreateFrameBuffer(lua_State* L)
{
	VkFramebuffer newFrameBuffer;

	VkFramebufferCreateInfo createInfo{};
	createInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;

	lua_len(L, 1);
	int numAttachments = lua_tointeger(L, -1);
	lua_pop(L, 1);

	std::vector<VkImageView> attachments;
	std::vector<Texture*> textures;

	for (int i = 0; i < numAttachments; i++)
	{
		lua_geti(L, 1, i + 1);
		lua_getfield(L, -1, "texture");
		textures.push_back((Texture*)lua_touserdata(L, -1));
		attachments.push_back(textures.back()->View);
		lua_pop(L, 1);
		lua_pop(L, 1);
	}

	createInfo.attachmentCount = numAttachments;
	createInfo.width = (uint32_t)lua_tonumber(L, 2);
	createInfo.height = (uint32_t)lua_tonumber(L, 3);
	createInfo.layers = 1;
	createInfo.pNext = NULL;
	createInfo.flags = VK_FLAGS_NONE;
	createInfo.pAttachments = attachments.data();
	RenderPass* pass = Lua_GetRenderPass(L, 4);
	createInfo.renderPass = pass->renderPass;

	vkCreateFramebuffer(g_App->backend->logicalDevice, &createInfo, NULL, &newFrameBuffer);

	lua_createtable(L, 0, 3);
	lua_pushlightuserdata(L, (void*)newFrameBuffer);
	lua_setfield(L, -2, "buffer");
	lua_pushnumber(L, createInfo.width);
	lua_setfield(L, -2, "width");
	lua_pushnumber(L, createInfo.height);
	lua_setfield(L, -2, "height");

	lua_createtable(L, numAttachments, 0);
	for (uint32_t i = 0; i < numAttachments; i++)
	{
		lua_pushlightuserdata(L, textures[i]);
		lua_seti(L, -2, i + 1);
	}
	lua_setfield(L, -2, "textures");

	LuaFN_PushRenderPass_NoGC(L, pass);
	lua_setfield(L, -2, "renderPass");

	lua_createtable(L, 0, 1);
	lua_pushcclosure(L, LuaFN_FrameBufferGC, 0);
	lua_setfield(L, -2, "__gc");
	lua_setmetatable(L, -2);
	return 1;
}

int LuaFN_SetActiveCamera(lua_State* L)
{
	lua_getfield(L, 1, "data");
		g_App->backend->SetActiveCamera((Camera*)lua_touserdata(L, -1));
	lua_pop(L, 1);
	return 0;
}

int LuaFN_GetActiveCamera(lua_State* L)
{
	Lua_PushCamera(L, g_App->backend->GetActiveCamera());
	return 1;
}

int LuaFN_SpawnObject(lua_State* L)
{
	return 0;
	/*
	MeshObject* mo = new MeshObject(*Lua_GetFloat3(L, 1), *Lua_GetFloat3(L, 2), *Lua_GetFloat3(L, 3), LoadMeshFromFile((char*)lua_tostring(L, 4)), LoadTexture(lua_tostring(L, 5), false, false, NULL), &g_App->backend->allMaterials[lua_tointeger(L, 6)], lua_tonumber(L, 7), lua_toboolean(L, 8), lua_toboolean(L, 9), lua_tointeger(L, 10), lua_type(L, 11) ? lua_tostring(L, 12) : NULL);

	g_App->backend->AddToMainRenderProcess(mo);

	Lua_PushMeshObject(L, mo);
	return 1;
	*/
}

int LuaFN_OneTimeBlit(lua_State* L)
{
	lua_getfield(L, 1, "texture");
	Texture* src = (Texture*)lua_touserdata(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, 2, "texture");
	Texture* dst = (Texture*)lua_touserdata(L, -1);
	lua_pop(L, 1);

	Rect srcArea, dstArea;

	srcArea = { 0, 0, src->Width, src->Height };
	dstArea = { 0, 0, dst->Width, dst->Height };

	auto filter = (VkFilter)lua_tointeger(L, 3);

	auto srcLayout = (VkImageLayout)lua_tointeger(L, 4);
	auto srcFinalLayout = (VkImageLayout)lua_tointeger(L, 5);
	auto dstFinalLayout = (VkImageLayout)lua_tointeger(L, 6);

	g_App->backend->OneTimeBlit(src->Image, srcArea, dst->Image, dstArea, srcLayout, filter, src->Aspect, dst->Aspect, srcFinalLayout, dstFinalLayout);
	vkDeviceWaitIdle(g_App->backend->logicalDevice);

	return 0;
}

int LuaFN_LoadImage(lua_State* L)
{
	Texture* tex = LoadTexture(lua_tostring(L, 1), false, false, NULL);
	Lua_PushTexture_NoGC(L, tex, tex->Width, tex->Height);
	return 1;
}

bool RecompileShaderThreadProc(void* glWindow)
{
	for (uint32_t i = 0; i < g_App->backend->numPipelines; i++)
	{
		Shader* pipeline = &g_App->backend->allPipelines[i];

		auto mod_time = FileDate(pipeline->zlslFile);
		if (mod_time != pipeline->mtime)
		{
			// This thread needs to sync with the main thread to make sure commands aren't being recorded while the shaders are recompiled
			threadAwaitingSync = true;
			while (!threadSynced)
			{
			}

			vkDeviceWaitIdle(g_App->backend->logicalDevice);

			printf("'%s' has changed\n", pipeline->zlslFile);
			pipeline->mtime = mod_time;
			g_App->RecompileShader(pipeline);
			g_App->backend->RecordPostProcessCommandBuffers();

			threadAwaitingSync = false;
			threadSynced = false;
		}
	}

	for (uint32_t i = 0; i < g_App->backend->allComputeShaders.size(); i++)
	{
		ComputeShader** shader = g_App->backend->allComputeShaders[i];
		size_t numUniforms, numStorageB, numStorageI, numSamplers;

		if (FileDate((*shader)->filename) > (*shader)->lastModified)
		{
			// This thread needs to sync with the main thread to make sure commands aren't being recorded while the shaders are recompiled
			threadAwaitingSync = true;
			while (!threadSynced);

			g_App->RecompileComputeShader(*shader);

			const char* filename = (*shader)->filename;
			numUniforms = (*shader)->numUniformBuffers;
			numStorageB = (*shader)->numStorageBuffers;
			numStorageI = (*shader)->numStorageImages;
			numSamplers = (*shader)->numSamplers;
			delete (*shader);
			*shader = new ComputeShader(g_App->backend, filename, numUniforms, numStorageB, numStorageI, numSamplers);

			threadAwaitingSync = false;
			threadSynced = false;
		}
	}
	return false;
}

int zThreadTick(void* thread)
{
	while (!((Thread*)thread)->shouldClose)
		if (((Thread*)thread)->function(((Thread*)thread)->udata)) break;

	thrd_exit(thrd_success);
	return 1;
}

void FullCreateImage(VkImageType imageType, VkImageViewType imageViewType, VkFormat imageFormat, int width, int height, int mipLevels, int arrayLayers, VkSampleCountFlagBits sampleCount, VkImageTiling imageTiling, VkImageUsageFlags usage, VkImageAspectFlags imageAspectFlags, VkFilter magFilter, VkFilter minFilter, VkSamplerAddressMode samplerAddressMode, VkImage& outImage, VkDeviceMemory& outMemory, VkImageView& outView, VkSampler& outSampler, bool addSamplerToList)
{
	g_App->backend->FullCreateImage(imageType, imageViewType, imageFormat, width, height, mipLevels, arrayLayers, sampleCount, imageTiling, usage, imageAspectFlags, magFilter, minFilter, samplerAddressMode, outImage, outMemory, outView, outSampler, addSamplerToList);
}
